{"version":3,"file":"hue-e4b7453b-bundle-3c690b33b5f47cc0d68b.js","sources":["webpack:///./desktop/core/src/desktop/js/catalog/DataCatalogEntry.ts","webpack:///./desktop/core/src/desktop/js/catalog/GeneralDataCatalog.ts","webpack:///./desktop/core/src/desktop/js/catalog/MultiTableEntry.ts","webpack:///./desktop/core/src/desktop/js/catalog/analyzer/ApiSqlAnalyzer.ts","webpack:///./desktop/core/src/desktop/js/catalog/analyzer/CombinedSqlAnalyser.ts","webpack:///./desktop/core/src/desktop/js/catalog/analyzer/NoopSqlAnalyzer.ts","webpack:///./desktop/core/src/desktop/js/catalog/analyzer/sqlAnalyzerRepository.ts","webpack:///./desktop/core/src/desktop/js/catalog/analyzer/types.ts","webpack:///./desktop/core/src/desktop/js/catalog/api.ts","webpack:///./desktop/core/src/desktop/js/catalog/catalogUtils.ts","webpack:///./desktop/core/src/desktop/js/catalog/contextCatalog.ts","webpack:///./desktop/core/src/desktop/js/catalog/dataCatalog.ts","webpack:///./desktop/core/src/desktop/js/catalog/events.ts"],"sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport * as ko from 'knockout';\nimport { CancellablePromise } from 'api/cancellablePromise';\nimport { addNavTags, deleteNavTags, fetchDescribe, fetchNavigatorMetadata, fetchPartitions, fetchSample, fetchSourceMetadata, searchEntities, updateNavigatorProperties, updateSourceMetadata } from 'catalog/api';\nimport { applyCancellable, forceSilencedErrors } from 'catalog/catalogUtils';\nimport huePubSub from 'utils/huePubSub';\nimport I18n from \"../utils/i18n\";\nimport { executeSingleStatement } from 'apps/editor/execution/api';\nimport { DataCatalog } from \"./dataCatalog\";\n\nvar cachedOnly = function cachedOnly(options) {\n  return !!(options && options.cachedOnly);\n};\n\nvar shouldReload = function shouldReload(options) {\n  return !!(!DataCatalog.cacheEnabled() || options && (options.refreshCache || options.refreshAnalysis));\n};\n/**\n * Helper function to get the multi table catalog version of a catalog entry\n */\n\n\nvar getMultiTableEntry = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(catalogEntry) {\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (catalogEntry.isTableOrView()) {\n              _context.next = 2;\n              break;\n            }\n\n            return _context.abrupt(\"return\", Promise.reject());\n\n          case 2:\n            return _context.abrupt(\"return\", catalogEntry.dataCatalog.getMultiTableEntry({\n              namespace: catalogEntry.namespace,\n              compute: catalogEntry.compute,\n              paths: [catalogEntry.path]\n            }));\n\n          case 3:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function getMultiTableEntry(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar DataCatalogEntry = /*#__PURE__*/function () {\n  function DataCatalogEntry(options) {\n    _classCallCheck(this, DataCatalogEntry);\n\n    this.compute = void 0;\n    this.dataCatalog = void 0;\n    this.definition = void 0;\n    this.isTemporary = void 0;\n    this.name = void 0;\n    this.namespace = void 0;\n    this.path = void 0;\n    this.saveTimeout = -1;\n    this.commentObservable = void 0;\n    this.analysis = void 0;\n    this.analysisPromise = void 0;\n    this.childrenPromise = void 0;\n    this.navigatorMeta = void 0;\n    this.navigatorMetaForChildrenPromise = void 0;\n    this.navigatorMetaPromise = void 0;\n    this.sqlAnalyzerMeta = void 0;\n    this.sqlAnalyzerMetaPromise = void 0;\n    this.sqlAnalyzerPopularity = void 0;\n    this.sqlAnalyzerPopularityForChildrenPromise = void 0;\n    this.partitions = void 0;\n    this.partitionsPromise = void 0;\n    this.sample = void 0;\n    this.samplePromise = void 0;\n    this.sourceMeta = void 0;\n    this.sourceMetaPromise = void 0;\n\n    if (!options.dataCatalog.connector) {\n      throw new Error('DataCatalogEntry created without connector');\n    }\n\n    this.namespace = options.namespace;\n    this.compute = options.compute;\n    this.dataCatalog = options.dataCatalog;\n    this.path = typeof options.path === 'string' ? options.path.split('.') : options.path || [];\n    this.name = this.path.length ? this.path[this.path.length - 1] : this.getConnector().id;\n    this.isTemporary = options.isTemporary;\n\n    if (options.definition) {\n      this.definition = options.definition;\n    } else if (this.path.length === 0) {\n      this.definition = {\n        type: 'source'\n      };\n    } else if (this.path.length === 1) {\n      this.definition = {\n        type: 'database'\n      };\n    } else if (this.path.length === 2) {\n      this.definition = {\n        type: 'table'\n      };\n    }\n\n    this.reset();\n  }\n  /**\n   * Resets the entry to an empty state, it might still have some details cached\n   */\n\n\n  _createClass(DataCatalogEntry, [{\n    key: \"reset\",\n    value: function reset() {\n      this.saveTimeout = -1;\n      this.analysis = undefined;\n      this.analysisPromise = undefined;\n      this.childrenPromise = undefined;\n      this.navigatorMeta = undefined;\n      this.navigatorMetaForChildrenPromise = undefined;\n      this.navigatorMetaPromise = undefined;\n      this.sqlAnalyzerMeta = undefined;\n      this.sqlAnalyzerMetaPromise = undefined;\n      this.sqlAnalyzerPopularity = undefined;\n      this.sqlAnalyzerPopularityForChildrenPromise = undefined;\n      this.partitions = undefined;\n      this.partitionsPromise = undefined;\n      this.sample = undefined;\n      this.samplePromise = undefined;\n      this.sourceMeta = undefined;\n      this.sourceMetaPromise = undefined;\n\n      if (this.path.length) {\n        this.dataCatalog.getKnownEntry({\n          namespace: this.namespace,\n          compute: this.compute,\n          path: this.path.slice(0, this.path.length - 1)\n        }).then(function (parent) {\n          if (parent) {\n            parent.navigatorMetaForChildrenPromise = undefined;\n            parent.sqlAnalyzerPopularityForChildrenPromise = undefined;\n          }\n        })[\"catch\"](function (err) {\n          console.warn(err);\n        });\n      }\n    }\n    /**\n     * Resets the entry and clears the cache\n     */\n\n  }, {\n    key: \"clearCache\",\n    value: function () {\n      var _clearCache = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(options) {\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!options) {\n                  options = {};\n                }\n\n                if (this.definition && this.definition.sqlAnalyzerLoaded) {\n                  delete this.definition.sqlAnalyzerLoaded;\n                }\n\n                this.reset();\n                _context2.prev = 3;\n\n                if (!options.cascade) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                _context2.next = 7;\n                return this.dataCatalog.clearStorageCascade(this.namespace, this.compute, this.path);\n\n              case 7:\n                _context2.next = 11;\n                break;\n\n              case 9:\n                _context2.next = 11;\n                return this.save();\n\n              case 11:\n                _context2.next = 15;\n                break;\n\n              case 13:\n                _context2.prev = 13;\n                _context2.t0 = _context2[\"catch\"](3);\n\n              case 15:\n                huePubSub.publish('data.catalog.entry.refreshed', {\n                  entry: this,\n                  cascade: !!options.cascade\n                });\n\n              case 16:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[3, 13]]);\n      }));\n\n      function clearCache(_x2) {\n        return _clearCache.apply(this, arguments);\n      }\n\n      return clearCache;\n    }()\n  }, {\n    key: \"reloadAnalysis\",\n    value: function reloadAnalysis(options) {\n      var _this = this;\n\n      this.analysisPromise = new CancellablePromise( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(resolve, reject, onCancel) {\n          var fetchPromise;\n          return regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  fetchPromise = fetchDescribe(_objectSpread({\n                    entry: _this\n                  }, options));\n                  onCancel(function () {\n                    fetchPromise.cancel();\n                  });\n                  _context3.prev = 2;\n                  _context3.next = 5;\n                  return fetchPromise;\n\n                case 5:\n                  _this.analysis = _context3.sent;\n                  resolve(_this.analysis);\n                  _context3.next = 13;\n                  break;\n\n                case 9:\n                  _context3.prev = 9;\n                  _context3.t0 = _context3[\"catch\"](2);\n                  reject(_context3.t0 || 'Fetch failed');\n                  return _context3.abrupt(\"return\");\n\n                case 13:\n                  _this.saveLater();\n\n                case 14:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3, null, [[2, 9]]);\n        }));\n\n        return function (_x3, _x4, _x5) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n      return applyCancellable(this.analysisPromise, options);\n    }\n  }, {\n    key: \"reloadNavigatorMeta\",\n    value: function reloadNavigatorMeta(options) {\n      var _this2 = this;\n\n      if (this.canHaveNavigatorMetadata()) {\n        this.navigatorMetaPromise = new CancellablePromise( /*#__PURE__*/function () {\n          var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(resolve, reject) {\n            return regeneratorRuntime.wrap(function _callee4$(_context4) {\n              while (1) {\n                switch (_context4.prev = _context4.next) {\n                  case 0:\n                    _context4.prev = 0;\n                    _context4.next = 3;\n                    return fetchNavigatorMetadata(_objectSpread(_objectSpread({}, options), {}, {\n                      entry: _this2\n                    }));\n\n                  case 3:\n                    _this2.navigatorMeta = _context4.sent;\n                    resolve(_this2.navigatorMeta);\n                    _context4.next = 11;\n                    break;\n\n                  case 7:\n                    _context4.prev = 7;\n                    _context4.t0 = _context4[\"catch\"](0);\n                    reject(_context4.t0 || 'Fetch failed');\n                    return _context4.abrupt(\"return\");\n\n                  case 11:\n                    _this2.saveLater();\n\n                    if (_this2.commentObservable) {\n                      _this2.commentObservable(_this2.getResolvedComment());\n                    }\n\n                  case 13:\n                  case \"end\":\n                    return _context4.stop();\n                }\n              }\n            }, _callee4, null, [[0, 7]]);\n          }));\n\n          return function (_x6, _x7) {\n            return _ref3.apply(this, arguments);\n          };\n        }());\n      } else {\n        this.navigatorMetaPromise = CancellablePromise.reject();\n      }\n\n      return applyCancellable(this.navigatorMetaPromise);\n    }\n    /**\n     * Helper function to reload the nav opt metadata for the given entry\n     */\n\n  }, {\n    key: \"reloadSqlAnalyzerMeta\",\n    value: function reloadSqlAnalyzerMeta(_ref4) {\n      var _this3 = this;\n\n      var cancellable = _ref4.cancellable,\n          silenceErrors = _ref4.silenceErrors,\n          sqlAnalyzer = _ref4.sqlAnalyzer;\n\n      if (this.dataCatalog.canHaveSqlAnalyzerMeta()) {\n        this.sqlAnalyzerMetaPromise = new CancellablePromise( /*#__PURE__*/function () {\n          var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(resolve, reject, onCancel) {\n            var fetchPromise;\n            return regeneratorRuntime.wrap(function _callee5$(_context5) {\n              while (1) {\n                switch (_context5.prev = _context5.next) {\n                  case 0:\n                    fetchPromise = sqlAnalyzer.fetchSqlAnalyzerMeta({\n                      path: _this3.path,\n                      silenceErrors: silenceErrors\n                    });\n                    onCancel(function () {\n                      fetchPromise.cancel();\n                    });\n                    _context5.prev = 2;\n                    _context5.next = 5;\n                    return fetchPromise;\n\n                  case 5:\n                    _this3.sqlAnalyzerMeta = _context5.sent;\n                    resolve(_this3.sqlAnalyzerMeta);\n                    _context5.next = 13;\n                    break;\n\n                  case 9:\n                    _context5.prev = 9;\n                    _context5.t0 = _context5[\"catch\"](2);\n                    reject(_context5.t0 || 'Fetch failed');\n                    return _context5.abrupt(\"return\");\n\n                  case 13:\n                    _this3.saveLater();\n\n                  case 14:\n                  case \"end\":\n                    return _context5.stop();\n                }\n              }\n            }, _callee5, null, [[2, 9]]);\n          }));\n\n          return function (_x8, _x9, _x10) {\n            return _ref5.apply(this, arguments);\n          };\n        }());\n      } else {\n        this.sqlAnalyzerMetaPromise = CancellablePromise.reject();\n      }\n\n      return applyCancellable(this.sqlAnalyzerMetaPromise, {\n        cancellable: cancellable\n      });\n    }\n  }, {\n    key: \"reloadPartitions\",\n    value: function reloadPartitions(options) {\n      var _this4 = this;\n\n      this.partitionsPromise = new CancellablePromise( /*#__PURE__*/function () {\n        var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(resolve, reject) {\n          return regeneratorRuntime.wrap(function _callee6$(_context6) {\n            while (1) {\n              switch (_context6.prev = _context6.next) {\n                case 0:\n                  _context6.prev = 0;\n                  _context6.next = 3;\n                  return fetchPartitions(_objectSpread(_objectSpread({}, options), {}, {\n                    entry: _this4\n                  }));\n\n                case 3:\n                  _this4.partitions = _context6.sent;\n                  resolve(_this4.partitions);\n                  _context6.next = 11;\n                  break;\n\n                case 7:\n                  _context6.prev = 7;\n                  _context6.t0 = _context6[\"catch\"](0);\n                  reject(_context6.t0 || 'Fetch failed');\n                  return _context6.abrupt(\"return\");\n\n                case 11:\n                  _this4.saveLater();\n\n                case 12:\n                case \"end\":\n                  return _context6.stop();\n              }\n            }\n          }, _callee6, null, [[0, 7]]);\n        }));\n\n        return function (_x11, _x12) {\n          return _ref6.apply(this, arguments);\n        };\n      }());\n      return applyCancellable(this.partitionsPromise, options);\n    }\n  }, {\n    key: \"reloadSample\",\n    value: function reloadSample(options) {\n      var _this5 = this;\n\n      this.samplePromise = new CancellablePromise( /*#__PURE__*/function () {\n        var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(resolve, reject) {\n          return regeneratorRuntime.wrap(function _callee7$(_context7) {\n            while (1) {\n              switch (_context7.prev = _context7.next) {\n                case 0:\n                  _context7.prev = 0;\n                  _context7.next = 3;\n                  return fetchSample(_objectSpread(_objectSpread({}, options), {}, {\n                    entry: _this5\n                  }));\n\n                case 3:\n                  _this5.sample = _context7.sent;\n                  resolve(_this5.sample);\n                  _context7.next = 11;\n                  break;\n\n                case 7:\n                  _context7.prev = 7;\n                  _context7.t0 = _context7[\"catch\"](0);\n                  reject(_context7.t0 || 'Fetch failed');\n                  return _context7.abrupt(\"return\");\n\n                case 11:\n                  _this5.saveLater();\n\n                case 12:\n                case \"end\":\n                  return _context7.stop();\n              }\n            }\n          }, _callee7, null, [[0, 7]]);\n        }));\n\n        return function (_x13, _x14) {\n          return _ref7.apply(this, arguments);\n        };\n      }());\n      return applyCancellable(this.samplePromise, options);\n    }\n  }, {\n    key: \"reloadSourceMeta\",\n    value: function reloadSourceMeta(options) {\n      var _this6 = this;\n\n      this.sourceMetaPromise = new CancellablePromise( /*#__PURE__*/function () {\n        var _ref8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(resolve, reject) {\n          return regeneratorRuntime.wrap(function _callee8$(_context8) {\n            while (1) {\n              switch (_context8.prev = _context8.next) {\n                case 0:\n                  if (!_this6.dataCatalog.invalidatePromise) {\n                    _context8.next = 8;\n                    break;\n                  }\n\n                  _context8.prev = 1;\n                  _context8.next = 4;\n                  return _this6.dataCatalog.invalidatePromise;\n\n                case 4:\n                  _context8.next = 8;\n                  break;\n\n                case 6:\n                  _context8.prev = 6;\n                  _context8.t0 = _context8[\"catch\"](1);\n\n                case 8:\n                  _context8.prev = 8;\n                  _context8.next = 11;\n                  return fetchSourceMetadata(_objectSpread(_objectSpread({}, options), {}, {\n                    entry: _this6\n                  }));\n\n                case 11:\n                  _this6.sourceMeta = _context8.sent;\n                  resolve(_this6.sourceMeta);\n                  _context8.next = 19;\n                  break;\n\n                case 15:\n                  _context8.prev = 15;\n                  _context8.t1 = _context8[\"catch\"](8);\n                  reject(_context8.t1 || 'Fetch failed');\n                  return _context8.abrupt(\"return\");\n\n                case 19:\n                  _this6.saveLater();\n\n                case 20:\n                case \"end\":\n                  return _context8.stop();\n              }\n            }\n          }, _callee8, null, [[1, 6], [8, 15]]);\n        }));\n\n        return function (_x15, _x16) {\n          return _ref8.apply(this, arguments);\n        };\n      }());\n      return applyCancellable(this.sourceMetaPromise, options);\n    }\n  }, {\n    key: \"drop\",\n    value: function drop(cascade) {\n      var _this7 = this;\n\n      if (!this.isDatabase() && !this.isTableOrView()) {\n        return CancellablePromise.reject('Drop is only possible for a database, table or view.');\n      }\n\n      var statement = \"DROP \".concat(this.isDatabase() ? 'DATABASE' : this.isView() ? 'VIEW' : 'TABLE', \" IF EXISTS `\").concat(this.path.join('`.`'), \"`\").concat(this.isDatabase() && cascade ? ' CASCADE;' : ';');\n      return new CancellablePromise(function (resolve, reject, onCancel) {\n        var executePromise = executeSingleStatement({\n          connector: _this7.getConnector(),\n          namespace: _this7.namespace,\n          compute: _this7.compute,\n          statement: statement\n        });\n        onCancel(function () {\n          executePromise.cancel();\n        });\n        executePromise.then(function () {\n          _this7.clearCache({\n            cascade: true\n          })[\"catch\"]();\n\n          resolve();\n        })[\"catch\"](reject);\n      });\n    }\n    /**\n     * Save the entry to cache\n     */\n\n  }, {\n    key: \"save\",\n    value: function () {\n      var _save = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {\n        return regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                window.clearTimeout(this.saveTimeout);\n                _context9.prev = 1;\n                _context9.next = 4;\n                return this.dataCatalog.persistCatalogEntry(this);\n\n              case 4:\n                _context9.next = 8;\n                break;\n\n              case 6:\n                _context9.prev = 6;\n                _context9.t0 = _context9[\"catch\"](1);\n\n              case 8:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[1, 6]]);\n      }));\n\n      function save() {\n        return _save.apply(this, arguments);\n      }\n\n      return save;\n    }()\n    /**\n     * Save the entry at a later point of time\n     */\n\n  }, {\n    key: \"saveLater\",\n    value: function saveLater() {\n      var _CACHEABLE_TTL,\n          _this8 = this;\n\n      if ((((_CACHEABLE_TTL = window.CACHEABLE_TTL) === null || _CACHEABLE_TTL === void 0 ? void 0 : _CACHEABLE_TTL[\"default\"]) || 0) > 0) {\n        window.clearTimeout(this.saveTimeout);\n        this.saveTimeout = window.setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {\n          return regeneratorRuntime.wrap(function _callee10$(_context10) {\n            while (1) {\n              switch (_context10.prev = _context10.next) {\n                case 0:\n                  _context10.next = 2;\n                  return _this8.save();\n\n                case 2:\n                case \"end\":\n                  return _context10.stop();\n              }\n            }\n          }, _callee10);\n        })), 1000);\n      }\n    }\n    /**\n     * Gets the parent entry, rejected if there's no parent.\n     */\n\n  }, {\n    key: \"getParent\",\n    value: function getParent() {\n      if (!this.path.length) {\n        return Promise.reject();\n      }\n\n      return this.dataCatalog.getEntry({\n        namespace: this.namespace,\n        compute: this.compute,\n        path: this.path.slice(0, this.path.length - 1)\n      });\n    }\n    /**\n     * Get the children of the catalog entry, columns for a table entry etc.\n     */\n\n  }, {\n    key: \"getChildren\",\n    value: function getChildren(options) {\n      var _this9 = this;\n\n      if (this.childrenPromise && this.childrenPromise.cancelled) {\n        this.childrenPromise = undefined;\n      }\n\n      if (!this.childrenPromise && cachedOnly(options)) {\n        return CancellablePromise.reject();\n      }\n\n      if (this.childrenPromise && !shouldReload(options)) {\n        return applyCancellable(this.childrenPromise, options);\n      }\n\n      this.childrenPromise = new CancellablePromise( /*#__PURE__*/function () {\n        var _ref10 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(resolve, reject, onCancel) {\n          var sourceMeta, cancelled, partitionKeys, tableSourceMeta, primaryKeys, foreignKeys, entities, promises, index, fieldSourceMeta, complexAttributes;\n          return regeneratorRuntime.wrap(function _callee11$(_context11) {\n            while (1) {\n              switch (_context11.prev = _context11.next) {\n                case 0:\n                  cancelled = false;\n                  onCancel(function () {\n                    cancelled = true;\n                  });\n                  _context11.prev = 2;\n                  _context11.next = 5;\n                  return _this9.getSourceMeta(options);\n\n                case 5:\n                  sourceMeta = _context11.sent;\n                  _context11.next = 10;\n                  break;\n\n                case 8:\n                  _context11.prev = 8;\n                  _context11.t0 = _context11[\"catch\"](2);\n\n                case 10:\n                  if (!cancelled) {\n                    _context11.next = 13;\n                    break;\n                  }\n\n                  reject('Cancelled');\n                  return _context11.abrupt(\"return\");\n\n                case 13:\n                  if (sourceMeta) {\n                    _context11.next = 16;\n                    break;\n                  }\n\n                  reject('No source meta found');\n                  return _context11.abrupt(\"return\");\n\n                case 16:\n                  if (!sourceMeta.notFound) {\n                    _context11.next = 19;\n                    break;\n                  }\n\n                  resolve([]);\n                  return _context11.abrupt(\"return\");\n\n                case 19:\n                  partitionKeys = {};\n                  tableSourceMeta = sourceMeta;\n\n                  if (tableSourceMeta.partition_keys) {\n                    tableSourceMeta.partition_keys.forEach(function (partitionKey) {\n                      partitionKeys[partitionKey.name] = true;\n                    });\n                  }\n\n                  primaryKeys = {};\n\n                  if (tableSourceMeta.primary_keys) {\n                    tableSourceMeta.primary_keys.forEach(function (primaryKey) {\n                      primaryKeys[primaryKey.name] = true;\n                    });\n                  }\n\n                  foreignKeys = {};\n\n                  if (tableSourceMeta.foreign_keys) {\n                    tableSourceMeta.foreign_keys.forEach(function (foreignKey) {\n                      foreignKeys[foreignKey.name] = foreignKey;\n                    });\n                  }\n\n                  entities = sourceMeta.databases || sourceMeta.tables_meta || sourceMeta.extended_columns || sourceMeta.fields || sourceMeta.columns || [];\n                  promises = [];\n                  index = 0;\n                  entities.forEach(function (entity) {\n                    if (!sourceMeta.databases || entity !== '_impala_builtins') {\n                      var _name = entity.name || entity;\n\n                      var promise = _this9.dataCatalog.getEntry({\n                        namespace: _this9.namespace,\n                        compute: _this9.compute,\n                        path: [].concat(_toConsumableArray(_this9.path), [_name])\n                      });\n\n                      promise.then(function (catalogEntry) {\n                        if (!catalogEntry.definition || typeof catalogEntry.definition.index === 'undefined') {\n                          var definition = _typeof(entity) === 'object' ? entity : {\n                            name: entity\n                          };\n\n                          if (!definition.type) {\n                            if (_this9.path.length === 0) {\n                              definition.type = 'database';\n                            } else if (_this9.path.length === 1) {\n                              definition.type = 'table';\n                            } else if (_this9.path.length === 2) {\n                              definition.type = 'column';\n                            }\n                          }\n\n                          if (sourceMeta.partition_keys) {\n                            definition.partitionKey = partitionKeys[_name];\n                          }\n\n                          if (sourceMeta.primary_keys) {\n                            definition.primaryKey = primaryKeys[_name];\n                          }\n\n                          if (sourceMeta.foreign_keys) {\n                            definition.foreignKey = foreignKeys[_name];\n                          }\n\n                          definition.index = index++;\n                          catalogEntry.definition = definition;\n                          catalogEntry.saveLater();\n                        }\n                      })[\"catch\"](function (err) {\n                        console.warn(err);\n                      });\n                      promises.push(promise);\n                    }\n                  }); // TODO: Move to connector attributes\n\n                  if (sourceMeta && (_this9.getDialect() === 'impala' || _this9.getDialect() === 'hive') && _this9.isComplex()) {\n                    fieldSourceMeta = sourceMeta;\n                    complexAttributes = fieldSourceMeta.type === 'map' ? ['key', 'value'] : ['item'];\n                    complexAttributes.forEach(function (path) {\n                      var definition = fieldSourceMeta[path];\n\n                      if (definition) {\n                        var promise = _this9.dataCatalog.getEntry({\n                          namespace: _this9.namespace,\n                          compute: _this9.compute,\n                          path: [].concat(_toConsumableArray(_this9.path), [path])\n                        });\n\n                        promise.then(function (catalogEntry) {\n                          if (!catalogEntry.definition || typeof catalogEntry.definition.index === 'undefined') {\n                            definition.index = index++;\n                            definition.isMapValue = path === 'value';\n                            catalogEntry.definition = definition;\n                            catalogEntry.saveLater();\n                          }\n                        })[\"catch\"](function (err) {\n                          console.warn(err);\n                        });\n                        promises.push(promise);\n                      }\n                    });\n                  }\n\n                  Promise.all(promises).then(resolve)[\"catch\"](reject);\n\n                case 32:\n                case \"end\":\n                  return _context11.stop();\n              }\n            }\n          }, _callee11, null, [[2, 8]]);\n        }));\n\n        return function (_x17, _x18, _x19) {\n          return _ref10.apply(this, arguments);\n        };\n      }());\n      return applyCancellable(this.childrenPromise, options);\n    }\n    /**\n     * Loads navigator metadata for children, only applicable to databases and tables\n     */\n\n  }, {\n    key: \"loadNavigatorMetaForChildren\",\n    value: function loadNavigatorMetaForChildren(options) {\n      var _this10 = this;\n\n      if (this.navigatorMetaForChildrenPromise && this.navigatorMetaForChildrenPromise.cancelled) {\n        this.navigatorMetaPromise = undefined;\n      }\n\n      options = forceSilencedErrors(options);\n\n      if (!this.canHaveNavigatorMetadata() || this.isField()) {\n        return CancellablePromise.resolve([]);\n      }\n\n      if (this.navigatorMetaForChildrenPromise && !shouldReload(options)) {\n        return applyCancellable(this.navigatorMetaForChildrenPromise, options);\n      }\n\n      this.navigatorMetaForChildrenPromise = new CancellablePromise( /*#__PURE__*/function () {\n        var _ref11 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(resolve, reject, onCancel) {\n          var cancellablePromises, _options, childPromise, children, someHaveNavMeta, query, rejectUnknown, searchPromise;\n\n          return regeneratorRuntime.wrap(function _callee12$(_context12) {\n            while (1) {\n              switch (_context12.prev = _context12.next) {\n                case 0:\n                  cancellablePromises = [];\n                  onCancel(function () {\n                    cancellablePromises.forEach(function (cancellable) {\n                      cancellable.cancel();\n                    });\n                  });\n                  _context12.prev = 2;\n                  childPromise = _this10.getChildren(options);\n                  cancellablePromises.push(childPromise);\n                  _context12.next = 7;\n                  return childPromise;\n\n                case 7:\n                  children = _context12.sent;\n                  someHaveNavMeta = children.some(function (childEntry) {\n                    return childEntry.navigatorMeta;\n                  });\n\n                  if (!(someHaveNavMeta && !shouldReload(options))) {\n                    _context12.next = 12;\n                    break;\n                  }\n\n                  resolve(children);\n                  return _context12.abrupt(\"return\");\n\n                case 12:\n                  // TODO: Add sourceType to nav search query\n                  query = _this10.path.length ? \"parentPath:\\\"/\".concat(_this10.path.join('/'), \"\\\" AND type:(table view field)\") : 'type:database';\n\n                  rejectUnknown = function rejectUnknown() {\n                    children.forEach(function (childEntry) {\n                      if (!childEntry.navigatorMeta) {\n                        childEntry.navigatorMeta = undefined;\n                        childEntry.navigatorMetaPromise = undefined;\n                      }\n                    });\n                  };\n\n                  searchPromise = searchEntities({\n                    query: query,\n                    rawQuery: true,\n                    limit: children.length,\n                    silenceErrors: (_options = options) === null || _options === void 0 ? void 0 : _options.silenceErrors\n                  });\n                  cancellablePromises.push(searchPromise);\n                  searchPromise.then(function (result) {\n                    if (result && result.entities) {\n                      var childEntryIndex = {};\n                      children.forEach(function (childEntry) {\n                        childEntryIndex[childEntry.name.toLowerCase()] = childEntry;\n                      });\n                      result.entities.forEach(function (entity) {\n                        var matchingChildEntry = childEntryIndex[(entity.original_name || entity.originalName).toLowerCase()];\n\n                        if (matchingChildEntry) {\n                          matchingChildEntry.navigatorMeta = entity;\n                          entity.hueTimestamp = Date.now();\n                          matchingChildEntry.navigatorMetaPromise = CancellablePromise.resolve(matchingChildEntry.navigatorMeta);\n\n                          if (entity && matchingChildEntry.commentObservable) {\n                            matchingChildEntry.commentObservable(matchingChildEntry.getResolvedComment());\n                          }\n\n                          matchingChildEntry.saveLater();\n                        }\n                      });\n                    }\n                  })[\"catch\"](function () {\n                    return resolve([]);\n                  })[\"finally\"](function () {\n                    rejectUnknown();\n                    resolve(children);\n                  });\n                  _context12.next = 23;\n                  break;\n\n                case 19:\n                  _context12.prev = 19;\n                  _context12.t0 = _context12[\"catch\"](2);\n                  resolve([]);\n                  return _context12.abrupt(\"return\");\n\n                case 23:\n                case \"end\":\n                  return _context12.stop();\n              }\n            }\n          }, _callee12, null, [[2, 19]]);\n        }));\n\n        return function (_x20, _x21, _x22) {\n          return _ref11.apply(this, arguments);\n        };\n      }());\n      return applyCancellable(this.navigatorMetaForChildrenPromise, options);\n    }\n    /**\n     * Helper function used when loading navopt metdata for children\n     */\n\n  }, {\n    key: \"applySqlAnalyzerResponseToChildren\",\n    value: function applySqlAnalyzerResponseToChildren(response, options) {\n      var _this11 = this;\n\n      if (!this.definition) {\n        this.definition = {};\n      }\n\n      this.definition.sqlAnalyzerLoaded = true;\n      this.saveLater();\n      return new CancellablePromise( /*#__PURE__*/function () {\n        var _ref12 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(resolve, reject, onCancel) {\n          var childPromise, childEntries, entriesByName, updatedIndex, addSqlAnalyzerPopularity, popularEntries;\n          return regeneratorRuntime.wrap(function _callee13$(_context13) {\n            while (1) {\n              switch (_context13.prev = _context13.next) {\n                case 0:\n                  childPromise = _this11.getChildren(options);\n                  onCancel(function () {\n                    childPromise.cancel();\n                  });\n                  _context13.prev = 2;\n                  _context13.next = 5;\n                  return childPromise;\n\n                case 5:\n                  childEntries = _context13.sent;\n                  entriesByName = {};\n                  childEntries.forEach(function (childEntry) {\n                    entriesByName[childEntry.name.toLowerCase()] = childEntry;\n                  });\n                  updatedIndex = {};\n\n                  if (_this11.isDatabase() && response.top_tables) {\n                    response.top_tables.forEach(function (topTable) {\n                      if (!topTable.name) {\n                        return;\n                      }\n\n                      var matchingChild = entriesByName[topTable.name.toLowerCase()];\n\n                      if (matchingChild) {\n                        matchingChild.sqlAnalyzerPopularity = topTable;\n                        matchingChild.saveLater();\n                        updatedIndex[matchingChild.getQualifiedPath()] = matchingChild;\n                      }\n                    });\n                  } else if (_this11.isTableOrView() && response.values) {\n                    addSqlAnalyzerPopularity = function addSqlAnalyzerPopularity(columns, type) {\n                      if (columns) {\n                        columns.forEach(function (column) {\n                          if (!column.columnName) {\n                            return;\n                          }\n\n                          var matchingChild = entriesByName[column.columnName.toLowerCase()];\n\n                          if (matchingChild) {\n                            if (!matchingChild.sqlAnalyzerPopularity) {\n                              matchingChild.sqlAnalyzerPopularity = {\n                                column_count: 0,\n                                columnCount: 0\n                              };\n                            }\n\n                            matchingChild.sqlAnalyzerPopularity[type] = column;\n                            matchingChild.saveLater();\n                            updatedIndex[matchingChild.getQualifiedPath()] = matchingChild;\n                          }\n                        });\n                      }\n                    };\n\n                    addSqlAnalyzerPopularity(response.values.filterColumns, 'filterColumn');\n                    addSqlAnalyzerPopularity(response.values.groupbyColumns, 'groupByColumn');\n                    addSqlAnalyzerPopularity(response.values.joinColumns, 'joinColumn');\n                    addSqlAnalyzerPopularity(response.values.orderbyColumns, 'orderByColumn');\n                    addSqlAnalyzerPopularity(response.values.selectColumns, 'selectColumn');\n                  }\n\n                  popularEntries = [];\n                  Object.keys(updatedIndex).forEach(function (path) {\n                    popularEntries.push(updatedIndex[path]);\n                  });\n                  resolve(popularEntries);\n                  _context13.next = 18;\n                  break;\n\n                case 15:\n                  _context13.prev = 15;\n                  _context13.t0 = _context13[\"catch\"](2);\n                  reject(_context13.t0);\n\n                case 18:\n                case \"end\":\n                  return _context13.stop();\n              }\n            }\n          }, _callee13, null, [[2, 15]]);\n        }));\n\n        return function (_x23, _x24, _x25) {\n          return _ref12.apply(this, arguments);\n        };\n      }());\n    }\n    /**\n     * Loads SQL Analyzer popularity for the children of this entry.\n     */\n\n  }, {\n    key: \"loadSqlAnalyzerPopularityForChildren\",\n    value: function loadSqlAnalyzerPopularityForChildren(options) {\n      var _this12 = this;\n\n      if (this.sqlAnalyzerPopularityForChildrenPromise && this.sqlAnalyzerPopularityForChildrenPromise.cancelled) {\n        this.sqlAnalyzerPopularityForChildrenPromise = undefined;\n      }\n\n      options.silenceErrors = true;\n\n      if (!this.dataCatalog.canHaveSqlAnalyzerMeta()) {\n        return CancellablePromise.reject();\n      }\n\n      if (this.sqlAnalyzerPopularityForChildrenPromise && !shouldReload(options)) {\n        return applyCancellable(this.sqlAnalyzerPopularityForChildrenPromise, options);\n      }\n\n      if (this.definition && this.definition.sqlAnalyzerLoaded && !shouldReload(options)) {\n        this.sqlAnalyzerPopularityForChildrenPromise = new CancellablePromise( /*#__PURE__*/function () {\n          var _ref13 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(resolve, reject, onCancel) {\n            var childPromise, _children;\n\n            return regeneratorRuntime.wrap(function _callee14$(_context14) {\n              while (1) {\n                switch (_context14.prev = _context14.next) {\n                  case 0:\n                    childPromise = _this12.getChildren(options);\n                    onCancel(function () {\n                      childPromise.cancel();\n                    });\n                    _context14.prev = 2;\n                    _context14.next = 5;\n                    return childPromise;\n\n                  case 5:\n                    _children = _context14.sent;\n                    resolve(_children.filter(function (child) {\n                      return child.sqlAnalyzerPopularity;\n                    }));\n                    _context14.next = 12;\n                    break;\n\n                  case 9:\n                    _context14.prev = 9;\n                    _context14.t0 = _context14[\"catch\"](2);\n                    reject(_context14.t0);\n\n                  case 12:\n                  case \"end\":\n                    return _context14.stop();\n                }\n              }\n            }, _callee14, null, [[2, 9]]);\n          }));\n\n          return function (_x26, _x27, _x28) {\n            return _ref13.apply(this, arguments);\n          };\n        }());\n      } else if (this.isDatabase() || this.isTableOrView()) {\n        this.sqlAnalyzerPopularityForChildrenPromise = new CancellablePromise( /*#__PURE__*/function () {\n          var _ref14 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(resolve, reject, onCancel) {\n            var cancellablePromises, popularityPromise, analyzerResponse, applyPromise, entries;\n            return regeneratorRuntime.wrap(function _callee15$(_context15) {\n              while (1) {\n                switch (_context15.prev = _context15.next) {\n                  case 0:\n                    cancellablePromises = [];\n                    onCancel(function () {\n                      cancellablePromises.forEach(function (cancellable) {\n                        return cancellable.cancel();\n                      });\n                    });\n                    popularityPromise = options.sqlAnalyzer.fetchPopularity(_objectSpread(_objectSpread({}, options), {}, {\n                      paths: [_this12.path]\n                    }));\n                    cancellablePromises.push(popularityPromise);\n                    _context15.prev = 4;\n                    _context15.next = 7;\n                    return popularityPromise;\n\n                  case 7:\n                    analyzerResponse = _context15.sent;\n                    applyPromise = _this12.applySqlAnalyzerResponseToChildren(analyzerResponse, options);\n                    cancellablePromises.push(applyPromise);\n                    _context15.next = 12;\n                    return applyPromise;\n\n                  case 12:\n                    entries = _context15.sent;\n                    resolve(entries);\n                    _context15.next = 19;\n                    break;\n\n                  case 16:\n                    _context15.prev = 16;\n                    _context15.t0 = _context15[\"catch\"](4);\n                    resolve([]);\n\n                  case 19:\n                  case \"end\":\n                    return _context15.stop();\n                }\n              }\n            }, _callee15, null, [[4, 16]]);\n          }));\n\n          return function (_x29, _x30, _x31) {\n            return _ref14.apply(this, arguments);\n          };\n        }());\n      } else {\n        this.sqlAnalyzerPopularityForChildrenPromise = CancellablePromise.resolve([]);\n      }\n\n      return applyCancellable(this.sqlAnalyzerPopularityForChildrenPromise);\n    }\n    /**\n     * Returns true if the catalog entry can have navigator metadata\n     */\n\n  }, {\n    key: \"canHaveNavigatorMetadata\",\n    value: function canHaveNavigatorMetadata() {\n      if (!window.HAS_CATALOG) {\n        return false;\n      } // TODO: Move to connector attributes\n\n\n      return (this.getDialect() === 'hive' || this.getDialect() === 'impala') && (this.isDatabase() || this.isTableOrView() || this.isColumn());\n    }\n    /**\n     * Returns the currently known comment without loading any additional metadata\n     */\n\n  }, {\n    key: \"getResolvedComment\",\n    value: function getResolvedComment() {\n      // TODO: Move to connector attributes\n      if (this.navigatorMeta && (this.getDialect() === 'hive' || this.getDialect() === 'impala')) {\n        if (this.navigatorMeta.description) {\n          return this.navigatorMeta.description;\n        }\n\n        if (this.navigatorMeta.originalDescription) {\n          return this.navigatorMeta.originalDescription;\n        }\n      }\n\n      if (this.definition && this.definition.comment) {\n        return this.definition.comment;\n      }\n\n      return this.sourceMeta && this.sourceMeta.comment || '';\n    }\n    /**\n     * This can be used to get an observable for the comment which will be updated once a comment has been\n     * resolved.\n     */\n\n  }, {\n    key: \"getCommentObservable\",\n    value: function getCommentObservable() {\n      if (!this.commentObservable) {\n        this.commentObservable = ko.observable(this.getResolvedComment());\n      }\n\n      return this.commentObservable;\n    }\n    /**\n     * Checks whether the comment is known and has been loaded from the proper source\n     */\n\n  }, {\n    key: \"hasResolvedComment\",\n    value: function hasResolvedComment() {\n      if (this.canHaveNavigatorMetadata()) {\n        return typeof this.navigatorMeta !== 'undefined';\n      }\n\n      return typeof this.sourceMeta !== 'undefined';\n    }\n    /**\n     * Gets the comment for this entry, fetching it if necessary from the proper source.\n     */\n\n  }, {\n    key: \"getComment\",\n    value: function getComment(options) {\n      var _this13 = this;\n\n      var promise = new CancellablePromise( /*#__PURE__*/function () {\n        var _ref15 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(resolve, reject, onCancel) {\n          var cancellablePromises, navigatorMetaPromise, navigatorMeta, sourceMetaPromise, sourceMeta;\n          return regeneratorRuntime.wrap(function _callee16$(_context16) {\n            while (1) {\n              switch (_context16.prev = _context16.next) {\n                case 0:\n                  cancellablePromises = [];\n                  onCancel(function () {\n                    cancellablePromises.forEach(function (cancellable) {\n                      return cancellable.cancel();\n                    });\n                  });\n\n                  if (!_this13.canHaveNavigatorMetadata()) {\n                    _context16.next = 16;\n                    break;\n                  }\n\n                  navigatorMetaPromise = _this13.getNavigatorMeta(options);\n                  cancellablePromises.push(navigatorMetaPromise);\n                  _context16.prev = 5;\n                  _context16.next = 8;\n                  return navigatorMetaPromise;\n\n                case 8:\n                  navigatorMeta = _context16.sent;\n\n                  if (!navigatorMeta) {\n                    _context16.next = 12;\n                    break;\n                  }\n\n                  resolve(navigatorMeta.description || navigatorMeta.originalDescription || '');\n                  return _context16.abrupt(\"return\");\n\n                case 12:\n                  _context16.next = 16;\n                  break;\n\n                case 14:\n                  _context16.prev = 14;\n                  _context16.t0 = _context16[\"catch\"](5);\n\n                case 16:\n                  if (!_this13.sourceMeta) {\n                    _context16.next = 20;\n                    break;\n                  }\n\n                  resolve(_this13.sourceMeta.comment || '');\n                  _context16.next = 35;\n                  break;\n\n                case 20:\n                  if (!(_this13.definition && _this13.definition.comment)) {\n                    _context16.next = 24;\n                    break;\n                  }\n\n                  resolve(_this13.definition.comment);\n                  _context16.next = 35;\n                  break;\n\n                case 24:\n                  sourceMetaPromise = _this13.getSourceMeta(options);\n                  _context16.prev = 25;\n                  _context16.next = 28;\n                  return sourceMetaPromise;\n\n                case 28:\n                  sourceMeta = _context16.sent;\n                  resolve(sourceMeta && sourceMeta.comment || '');\n                  _context16.next = 35;\n                  break;\n\n                case 32:\n                  _context16.prev = 32;\n                  _context16.t1 = _context16[\"catch\"](25);\n                  reject(_context16.t1);\n\n                case 35:\n                case \"end\":\n                  return _context16.stop();\n              }\n            }\n          }, _callee16, null, [[5, 14], [25, 32]]);\n        }));\n\n        return function (_x32, _x33, _x34) {\n          return _ref15.apply(this, arguments);\n        };\n      }());\n      return applyCancellable(promise);\n    }\n    /**\n     * Updates custom navigator metadata for the catalog entry\n     */\n\n  }, {\n    key: \"updateNavigatorCustomMetadata\",\n    value: function () {\n      var _updateNavigatorCustomMetadata = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(modifiedCustomMetadata, deletedCustomMetadataKeys, apiOptions) {\n        var _this14 = this;\n\n        var navigatorMeta;\n        return regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                if (this.canHaveNavigatorMetadata()) {\n                  _context17.next = 2;\n                  break;\n                }\n\n                return _context17.abrupt(\"return\", Promise.reject());\n\n              case 2:\n                _context17.next = 4;\n                return this.getNavigatorMeta(apiOptions);\n\n              case 4:\n                navigatorMeta = _context17.sent;\n\n                if (navigatorMeta) {\n                  _context17.next = 7;\n                  break;\n                }\n\n                throw new Error('Could not load navigator metadata.');\n\n              case 7:\n                return _context17.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  updateNavigatorProperties({\n                    identity: navigatorMeta.identity,\n                    modifiedCustomMetadata: modifiedCustomMetadata,\n                    deletedCustomMetadataKeys: deletedCustomMetadataKeys\n                  }).then(function (entity) {\n                    if (entity) {\n                      _this14.navigatorMeta = entity;\n                      _this14.navigatorMetaPromise = CancellablePromise.resolve(entity);\n\n                      _this14.saveLater();\n\n                      resolve(entity);\n                    } else {\n                      reject();\n                    }\n                  })[\"catch\"](reject);\n                }));\n\n              case 8:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function updateNavigatorCustomMetadata(_x35, _x36, _x37) {\n        return _updateNavigatorCustomMetadata.apply(this, arguments);\n      }\n\n      return updateNavigatorCustomMetadata;\n    }()\n    /**\n     * Sets the comment in the proper source\n     */\n\n  }, {\n    key: \"setComment\",\n    value: function () {\n      var _setComment = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(comment, options) {\n        var _this15 = this;\n\n        var navigatorMeta;\n        return regeneratorRuntime.wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                if (!this.canHaveNavigatorMetadata()) {\n                  _context20.next = 7;\n                  break;\n                }\n\n                _context20.next = 3;\n                return this.getNavigatorMeta(options);\n\n              case 3:\n                navigatorMeta = _context20.sent;\n\n                if (navigatorMeta) {\n                  _context20.next = 6;\n                  break;\n                }\n\n                throw new Error('Could not load navigator metadata.');\n\n              case 6:\n                return _context20.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  updateNavigatorProperties({\n                    identity: navigatorMeta.identity,\n                    properties: {\n                      description: comment\n                    }\n                  }).then( /*#__PURE__*/function () {\n                    var _ref16 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(entity) {\n                      return regeneratorRuntime.wrap(function _callee18$(_context18) {\n                        while (1) {\n                          switch (_context18.prev = _context18.next) {\n                            case 0:\n                              if (entity) {\n                                _this15.navigatorMeta = entity;\n                                _this15.navigatorMetaPromise = CancellablePromise.resolve(entity);\n\n                                _this15.saveLater();\n                              }\n\n                              _this15.getComment(options).then(function (comment) {\n                                if (_this15.commentObservable) {\n                                  _this15.commentObservable(comment);\n                                }\n\n                                resolve(comment);\n                              })[\"catch\"](reject);\n\n                            case 2:\n                            case \"end\":\n                              return _context18.stop();\n                          }\n                        }\n                      }, _callee18);\n                    }));\n\n                    return function (_x40) {\n                      return _ref16.apply(this, arguments);\n                    };\n                  }())[\"catch\"](reject);\n                }));\n\n              case 7:\n                return _context20.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  updateSourceMetadata({\n                    entry: _this15,\n                    properties: {\n                      comment: comment\n                    },\n                    silenceErrors: options === null || options === void 0 ? void 0 : options.silenceErrors\n                  }).then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19() {\n                    var _comment;\n\n                    return regeneratorRuntime.wrap(function _callee19$(_context19) {\n                      while (1) {\n                        switch (_context19.prev = _context19.next) {\n                          case 0:\n                            _context19.prev = 0;\n                            _context19.next = 3;\n                            return _this15.reloadSourceMeta(options);\n\n                          case 3:\n                            _context19.next = 5;\n                            return _this15.getComment(options);\n\n                          case 5:\n                            _comment = _context19.sent;\n\n                            if (_this15.commentObservable) {\n                              _this15.commentObservable(_comment);\n                            }\n\n                            resolve(_comment);\n                            _context19.next = 13;\n                            break;\n\n                          case 10:\n                            _context19.prev = 10;\n                            _context19.t0 = _context19[\"catch\"](0);\n                            reject(_context19.t0);\n\n                          case 13:\n                          case \"end\":\n                            return _context19.stop();\n                        }\n                      }\n                    }, _callee19, null, [[0, 10]]);\n                  })))[\"catch\"](reject);\n                }));\n\n              case 8:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this);\n      }));\n\n      function setComment(_x38, _x39) {\n        return _setComment.apply(this, arguments);\n      }\n\n      return setComment;\n    }()\n    /**\n     * Adds a list of tags and updates the navigator metadata of the entry\n     */\n\n  }, {\n    key: \"addNavigatorTags\",\n    value: function () {\n      var _addNavigatorTags = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(tags, apiOptions) {\n        var _this16 = this;\n\n        var navigatorMeta;\n        return regeneratorRuntime.wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                if (this.canHaveNavigatorMetadata()) {\n                  _context21.next = 2;\n                  break;\n                }\n\n                return _context21.abrupt(\"return\", Promise.reject());\n\n              case 2:\n                _context21.next = 4;\n                return this.getNavigatorMeta(apiOptions);\n\n              case 4:\n                navigatorMeta = _context21.sent;\n                return _context21.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  addNavTags(navigatorMeta.identity, tags).then(function (entity) {\n                    if (entity) {\n                      _this16.navigatorMeta = entity;\n                      _this16.navigatorMetaPromise = CancellablePromise.resolve(entity);\n\n                      _this16.saveLater();\n\n                      resolve(entity);\n                    } else {\n                      reject();\n                    }\n                  })[\"catch\"](reject);\n                }));\n\n              case 6:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this);\n      }));\n\n      function addNavigatorTags(_x41, _x42) {\n        return _addNavigatorTags.apply(this, arguments);\n      }\n\n      return addNavigatorTags;\n    }()\n    /**\n     * Removes a list of tags and updates the navigator metadata of the entry\n     */\n\n  }, {\n    key: \"deleteNavigatorTags\",\n    value: function () {\n      var _deleteNavigatorTags = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(tags, apiOptions) {\n        var _this17 = this;\n\n        var navigatorMeta;\n        return regeneratorRuntime.wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                if (this.canHaveNavigatorMetadata()) {\n                  _context22.next = 2;\n                  break;\n                }\n\n                return _context22.abrupt(\"return\", Promise.reject());\n\n              case 2:\n                _context22.next = 4;\n                return this.getNavigatorMeta(apiOptions);\n\n              case 4:\n                navigatorMeta = _context22.sent;\n                return _context22.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  deleteNavTags(navigatorMeta.identity, tags).then(function (entity) {\n                    if (entity) {\n                      _this17.navigatorMeta = entity;\n                      _this17.navigatorMetaPromise = CancellablePromise.resolve(entity);\n\n                      _this17.saveLater();\n\n                      resolve(entity);\n                    } else {\n                      reject();\n                    }\n                  })[\"catch\"](reject);\n                }));\n\n              case 6:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this);\n      }));\n\n      function deleteNavigatorTags(_x43, _x44) {\n        return _deleteNavigatorTags.apply(this, arguments);\n      }\n\n      return deleteNavigatorTags;\n    }()\n    /**\n     * Checks if the entry can have children or not without fetching additional metadata.\n     */\n\n  }, {\n    key: \"hasPossibleChildren\",\n    value: function hasPossibleChildren() {\n      return this.path.length < 3 || !this.definition && !this.sourceMeta || !!this.sourceMeta && /^(?:struct|array|map)/i.test(this.sourceMeta.type) || !!this.definition && !!this.definition.type && /^(?:struct|array|map)/i.test(this.definition.type);\n    }\n    /**\n     * Returns the index representing the order in which the backend returned this entry.\n     */\n\n  }, {\n    key: \"getIndex\",\n    value: function getIndex() {\n      return this.definition && this.definition.index || 0;\n    }\n    /**\n     * Returns the dialect of this entry.\n     */\n\n  }, {\n    key: \"getDialect\",\n    value: function getDialect() {\n      return this.getConnector().dialect || this.getConnector().id; // .id for editor v1\n    }\n    /**\n     * Returns the connector for this entry\n     */\n\n  }, {\n    key: \"getConnector\",\n    value: function getConnector() {\n      return this.dataCatalog.connector;\n    }\n    /**\n     * Returns true if the entry represents a data source.\n     *\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"isSource\",\n    value: function isSource() {\n      return this.path.length === 0;\n    }\n    /**\n     * Returns true if the entry is a database.\n     */\n\n  }, {\n    key: \"isDatabase\",\n    value: function isDatabase() {\n      return this.path.length === 1;\n    }\n    /**\n     * Returns true if the entry is a table or a view.\n     *\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"isTableOrView\",\n    value: function isTableOrView() {\n      return this.path.length === 2;\n    }\n    /**\n     * Returns the default title used for the entry, the qualified path with type for fields. Optionally include\n     * the comment after, if already resolved.\n     */\n\n  }, {\n    key: \"getTitle\",\n    value: function getTitle(includeComment) {\n      var title = this.getQualifiedPath();\n\n      if (this.isField()) {\n        var type = this.getType();\n\n        if (type) {\n          title += ' (' + type + ')';\n        }\n      } else if (this.definition && this.definition.type && this.definition.type.toLowerCase() === 'materialized_view') {\n        title += ' (' + I18n('Materialized') + ')';\n      }\n\n      if (includeComment && this.hasResolvedComment() && this.getResolvedComment()) {\n        title += ' - ' + this.getResolvedComment();\n      }\n\n      return title;\n    }\n    /**\n     * Returns the fully qualified path for this entry.\n     */\n\n  }, {\n    key: \"getQualifiedPath\",\n    value: function getQualifiedPath() {\n      return this.path.join('.');\n    }\n    /**\n     * Returns the display name for the entry, name or qualified path plus type for fields\n     */\n\n  }, {\n    key: \"getDisplayName\",\n    value: function getDisplayName(qualified) {\n      var displayName = qualified ? this.getQualifiedPath() : this.name;\n\n      if (this.isField()) {\n        var type = this.getType();\n\n        if (type) {\n          return \"\".concat(displayName, \" (\").concat(type, \")\");\n        }\n      }\n\n      return displayName;\n    }\n    /**\n     * Returns true for columns that are a primary key. Note that the definition has to come from a parent entry, i.e.\n     * getChildren().\n     */\n\n  }, {\n    key: \"isPrimaryKey\",\n    value: function isPrimaryKey() {\n      return !!(this.isColumn() && this.definition && this.definition.primaryKey);\n    }\n    /**\n     * Returns true if the entry is a partition key. Note that the definition has to come from a parent entry, i.e.\n     * getChildren().\n     */\n\n  }, {\n    key: \"isPartitionKey\",\n    value: function isPartitionKey() {\n      return !!(this.definition && this.definition.partitionKey);\n    }\n    /**\n     * Returns true if the entry is a foreign key. Note that the definition has to come from a parent entry, i.e.\n     * getChildren().\n     */\n\n  }, {\n    key: \"isForeignKey\",\n    value: function isForeignKey() {\n      return !!this.definition && !!this.definition.foreignKey;\n    }\n    /**\n     * Returns true if the entry is either a partition or primary key. Note that the definition has to come from a parent entry, i.e.\n     * getChildren().\n     */\n\n  }, {\n    key: \"isKey\",\n    value: function isKey() {\n      return this.isPartitionKey() || this.isPrimaryKey() || this.isForeignKey();\n    }\n    /**\n     * Returns true if the entry is a table. It will be accurate once the source meta has been loaded.\n     */\n\n  }, {\n    key: \"isTable\",\n    value: function isTable() {\n      if (this.path.length === 2) {\n        if (this.analysis && this.analysis.details && this.analysis.details.properties && this.analysis.details.properties.table_type === 'VIRTUAL_VIEW') {\n          return false;\n        }\n\n        if (this.sourceMeta) {\n          return !this.sourceMeta.is_view;\n        }\n\n        if (this.definition && this.definition.type) {\n          return this.definition.type.toLowerCase() === 'table';\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Returns true if the entry is a view. It will be accurate once the source meta has been loaded.\n     */\n\n  }, {\n    key: \"isView\",\n    value: function isView() {\n      if (this.path.length === 2) {\n        if (this.sourceMeta && this.sourceMeta.is_view) {\n          return true;\n        }\n\n        if (this.definition && this.definition.type && (this.definition.type.toLowerCase() === 'view' || this.definition.type.toLowerCase() === 'materialized_view')) {\n          return true;\n        }\n\n        if (this.analysis && this.analysis.details && this.analysis.details.properties && this.analysis.details.properties.table_type === 'VIRTUAL_VIEW') {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Returns true if the entry is a ML Model. It will be accurate once the source meta has been loaded.\n     */\n\n  }, {\n    key: \"isModel\",\n    value: function isModel() {\n      return this.path.length === 2 && !!this.definition && !!this.definition.type && this.definition.type.toLowerCase() === 'model';\n    }\n    /**\n     * Returns true if the entry is a column.\n     */\n\n  }, {\n    key: \"isColumn\",\n    value: function isColumn() {\n      return this.path.length === 3;\n    }\n    /**\n     * Returns true if the entry is a column. It will be accurate once the source meta has been loaded or if loaded from\n     * a parent entry via getChildren().\n     */\n\n  }, {\n    key: \"isComplex\",\n    value: function isComplex() {\n      var sourceMeta = this.sourceMeta;\n      return !!(this.path.length > 2 && (sourceMeta && /^(?:struct|array|map)/i.test(sourceMeta.type) || this.definition && this.definition.type && /^(?:struct|array|map)/i.test(this.definition.type)));\n    }\n    /**\n     * Returns true if the entry is a field, i.e. column or child of a complex type.\n     */\n\n  }, {\n    key: \"isField\",\n    value: function isField() {\n      return this.path.length > 2;\n    }\n    /**\n     * Returns true if the entry is an array. It will be accurate once the source meta has been loaded or if loaded from\n     * a parent entry via getChildren().\n     */\n\n  }, {\n    key: \"isArray\",\n    value: function isArray() {\n      return !!this.sourceMeta && /^array/i.test(this.sourceMeta.type) || !!this.definition && !!this.definition.type && /^array/i.test(this.definition.type);\n    }\n    /**\n     * Returns true if the entry is a map. It will be accurate once the source meta has been loaded or if loaded from\n     * a parent entry via getChildren().\n     */\n\n  }, {\n    key: \"isMap\",\n    value: function isMap() {\n      return !!this.sourceMeta && /^map/i.test(this.sourceMeta.type) || !!this.definition && !!this.definition.type && /^map/i.test(this.definition.type);\n    }\n    /**\n     * Returns true if the entry is a map value. It will be accurate once the source meta has been loaded or if loaded\n     * from a parent entry via getChildren().\n     */\n\n  }, {\n    key: \"isMapValue\",\n    value: function isMapValue() {\n      return !!this.definition && !!this.definition.isMapValue;\n    }\n    /**\n     * Returns the type of the entry. It will be accurate once the source meta has been loaded or if loaded from\n     * a parent entry via getChildren().\n     *\n     * The returned string is always lower case and for complex entries the type definition is stripped to\n     * either 'array', 'map' or 'struct'.\n     */\n\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      var type = this.getRawType();\n\n      if (type.indexOf('<') !== -1) {\n        type = type.substring(0, type.indexOf('<'));\n      }\n\n      return type.toLowerCase();\n    }\n    /**\n     * Returns the raw type of the entry. It will be accurate once the source meta has been loaded or if loaded from\n     * a parent entry via getChildren().\n     *\n     * For complex entries the type definition is the full version.\n     */\n\n  }, {\n    key: \"getRawType\",\n    value: function getRawType() {\n      return this.sourceMeta && this.sourceMeta.type || this.definition && this.definition.type || '';\n    }\n    /**\n     * Gets the source metadata for the entry. It will fetch it if not cached or if the refresh option is set.\n     */\n\n  }, {\n    key: \"getSourceMeta\",\n    value: function getSourceMeta(options) {\n      if (this.sourceMetaPromise && this.sourceMetaPromise.cancelled) {\n        this.sourceMetaPromise = undefined;\n      }\n\n      if (!this.sourceMetaPromise && cachedOnly(options)) {\n        return CancellablePromise.reject();\n      }\n\n      if (!this.sourceMetaPromise || shouldReload(options)) {\n        return this.reloadSourceMeta(options);\n      }\n\n      return applyCancellable(this.sourceMetaPromise, options);\n    }\n    /**\n     * Gets the analysis for the entry. It will fetch it if not cached or if the refresh option is set.\n     */\n\n  }, {\n    key: \"getAnalysis\",\n    value: function getAnalysis(options) {\n      if (this.analysisPromise && this.analysisPromise.cancelled) {\n        this.analysisPromise = undefined;\n      }\n\n      if (!this.analysisPromise && cachedOnly(options)) {\n        return CancellablePromise.reject();\n      }\n\n      if (!this.analysisPromise || shouldReload(options)) {\n        return this.reloadAnalysis(options);\n      }\n\n      return applyCancellable(this.analysisPromise, options);\n    }\n    /**\n     * Gets the partitions for the entry. It will fetch it if not cached or if the refresh option is set.\n     */\n\n  }, {\n    key: \"getPartitions\",\n    value: function getPartitions(options) {\n      if (this.partitionsPromise && this.partitionsPromise.cancelled) {\n        this.partitionsPromise = undefined;\n      }\n\n      if (!this.isTableOrView() || !this.partitionsPromise && cachedOnly(options)) {\n        return CancellablePromise.reject();\n      }\n\n      if (!this.partitionsPromise || shouldReload(options)) {\n        return this.reloadPartitions(options);\n      }\n\n      return applyCancellable(this.partitionsPromise, options);\n    }\n    /**\n     * Gets the Navigator metadata for the entry. It will fetch it if not cached or if the refresh option is set.\n     */\n\n  }, {\n    key: \"getNavigatorMeta\",\n    value: function getNavigatorMeta(options) {\n      if (this.navigatorMetaPromise && this.navigatorMetaPromise.cancelled) {\n        this.navigatorMetaPromise = undefined;\n      }\n\n      options = forceSilencedErrors(options);\n\n      if (!this.canHaveNavigatorMetadata() || !this.navigatorMetaPromise && cachedOnly(options)) {\n        return CancellablePromise.reject();\n      }\n\n      if (!this.navigatorMetaPromise || shouldReload(options)) {\n        return this.reloadNavigatorMeta(options);\n      }\n\n      return applyCancellable(this.navigatorMetaPromise, options);\n    }\n    /**\n     * Gets the SQL Analyzer metadata for the entry. It will fetch it if not cached or if the refresh option is set.\n     */\n\n  }, {\n    key: \"getSqlAnalyzerMeta\",\n    value: function getSqlAnalyzerMeta(options) {\n      if (this.sqlAnalyzerMetaPromise && this.sqlAnalyzerMetaPromise.cancelled) {\n        this.sqlAnalyzerMetaPromise = undefined;\n      }\n\n      options.silenceErrors = true;\n\n      if (!this.dataCatalog.canHaveSqlAnalyzerMeta() || !this.isTableOrView()) {\n        return CancellablePromise.reject();\n      }\n\n      if (!this.sqlAnalyzerMetaPromise && cachedOnly(options)) {\n        return CancellablePromise.reject();\n      }\n\n      if (!this.sqlAnalyzerMetaPromise || shouldReload(options)) {\n        return this.reloadSqlAnalyzerMeta(options);\n      }\n\n      return applyCancellable(this.sqlAnalyzerMetaPromise, options);\n    }\n    /**\n     * Gets the sample for the entry, if unknown it will first check if any parent table already has the sample. It\n     * will fetch it if not cached or if the refresh option is set.\n     */\n\n  }, {\n    key: \"getSample\",\n    value: function getSample(options) {\n      var _this18 = this;\n\n      if (this.samplePromise && this.samplePromise.cancelled) {\n        this.samplePromise = undefined;\n      } // This prevents caching of any non-standard sample queries, i.e. DISTINCT etc.\n\n\n      if (options && options.operation && options.operation !== 'default') {\n        var operation = options.operation;\n        var samplePromise = fetchSample({\n          entry: this,\n          operation: operation,\n          silenceErrors: options.silenceErrors\n        });\n        return applyCancellable(samplePromise, options);\n      } // Check if parent has a sample that we can reuse\n\n\n      if (!this.samplePromise && this.isColumn() && !shouldReload(options)) {\n        this.samplePromise = new CancellablePromise( /*#__PURE__*/function () {\n          var _ref18 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24(resolve, reject, onCancel) {\n            var cancellablePromises, tableEntry, _ret, reloadPromise;\n\n            return regeneratorRuntime.wrap(function _callee24$(_context24) {\n              while (1) {\n                switch (_context24.prev = _context24.next) {\n                  case 0:\n                    cancellablePromises = [];\n                    onCancel(function () {\n                      cancellablePromises.forEach(function (promise) {\n                        return promise.cancel();\n                      });\n                    });\n                    _context24.prev = 2;\n                    _context24.next = 5;\n                    return _this18.dataCatalog.getEntry({\n                      namespace: _this18.namespace,\n                      compute: _this18.compute,\n                      path: _this18.path.slice(0, 2),\n                      definition: {\n                        type: 'table'\n                      }\n                    });\n\n                  case 5:\n                    tableEntry = _context24.sent;\n\n                    if (!(tableEntry && tableEntry.samplePromise)) {\n                      _context24.next = 11;\n                      break;\n                    }\n\n                    return _context24.delegateYield( /*#__PURE__*/regeneratorRuntime.mark(function _callee23() {\n                      var parentSample, colSample, _loop, i, _ret2;\n\n                      return regeneratorRuntime.wrap(function _callee23$(_context23) {\n                        while (1) {\n                          switch (_context23.prev = _context23.next) {\n                            case 0:\n                              cancellablePromises.push(applyCancellable(tableEntry.samplePromise, options));\n                              _context23.next = 3;\n                              return tableEntry.samplePromise;\n\n                            case 3:\n                              parentSample = _context23.sent;\n                              colSample = {\n                                hueTimestamp: parentSample.hueTimestamp,\n                                has_more: parentSample.has_more,\n                                type: parentSample.type,\n                                data: [],\n                                meta: []\n                              };\n\n                              if (!parentSample.meta) {\n                                _context23.next = 15;\n                                break;\n                              }\n\n                              _loop = function _loop(i) {\n                                if (parentSample.meta[i].name.toLowerCase() === _this18.name.toLowerCase()) {\n                                  colSample.meta[0] = parentSample.meta[i];\n                                  parentSample.data.forEach(function (parentRow) {\n                                    colSample.data.push([parentRow[i]]);\n                                  });\n                                  return \"break\";\n                                }\n                              };\n\n                              i = 0;\n\n                            case 8:\n                              if (!(i < parentSample.meta.length)) {\n                                _context23.next = 15;\n                                break;\n                              }\n\n                              _ret2 = _loop(i);\n\n                              if (!(_ret2 === \"break\")) {\n                                _context23.next = 12;\n                                break;\n                              }\n\n                              return _context23.abrupt(\"break\", 15);\n\n                            case 12:\n                              i++;\n                              _context23.next = 8;\n                              break;\n\n                            case 15:\n                              if (!colSample.meta.length) {\n                                _context23.next = 19;\n                                break;\n                              }\n\n                              _this18.sample = colSample;\n                              resolve(_this18.sample);\n                              return _context23.abrupt(\"return\", {\n                                v: void 0\n                              });\n\n                            case 19:\n                            case \"end\":\n                              return _context23.stop();\n                          }\n                        }\n                      }, _callee23);\n                    })(), \"t0\", 8);\n\n                  case 8:\n                    _ret = _context24.t0;\n\n                    if (!(_typeof(_ret) === \"object\")) {\n                      _context24.next = 11;\n                      break;\n                    }\n\n                    return _context24.abrupt(\"return\", _ret.v);\n\n                  case 11:\n                    _context24.next = 15;\n                    break;\n\n                  case 13:\n                    _context24.prev = 13;\n                    _context24.t1 = _context24[\"catch\"](2);\n\n                  case 15:\n                    if (!cachedOnly(options)) {\n                      _context24.next = 19;\n                      break;\n                    }\n\n                    reject();\n                    _context24.next = 31;\n                    break;\n\n                  case 19:\n                    reloadPromise = _this18.reloadSample(options);\n                    _context24.prev = 20;\n                    _context24.t2 = resolve;\n                    _context24.next = 24;\n                    return reloadPromise;\n\n                  case 24:\n                    _context24.t3 = _context24.sent;\n                    (0, _context24.t2)(_context24.t3);\n                    _context24.next = 31;\n                    break;\n\n                  case 28:\n                    _context24.prev = 28;\n                    _context24.t4 = _context24[\"catch\"](20);\n                    reject();\n\n                  case 31:\n                  case \"end\":\n                    return _context24.stop();\n                }\n              }\n            }, _callee24, null, [[2, 13], [20, 28]]);\n          }));\n\n          return function (_x45, _x46, _x47) {\n            return _ref18.apply(this, arguments);\n          };\n        }());\n        return applyCancellable(this.samplePromise, options);\n      }\n\n      if (!this.samplePromise && cachedOnly(options)) {\n        return CancellablePromise.reject();\n      }\n\n      if (!this.samplePromise || shouldReload(options)) {\n        return this.reloadSample(options);\n      }\n\n      return applyCancellable(this.samplePromise, options);\n    }\n    /**\n     * Gets the top aggregate UDFs for the entry if it's a table or view. It will fetch it if not cached or if the refresh option is set.\n     */\n\n  }, {\n    key: \"getTopAggs\",\n    value: function getTopAggs(options) {\n      var _this19 = this;\n\n      var promise = new CancellablePromise( /*#__PURE__*/function () {\n        var _ref19 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(resolve, reject, onCancel) {\n          var multiTableEntry, topAggsPromise;\n          return regeneratorRuntime.wrap(function _callee25$(_context25) {\n            while (1) {\n              switch (_context25.prev = _context25.next) {\n                case 0:\n                  _context25.next = 2;\n                  return getMultiTableEntry(_this19);\n\n                case 2:\n                  multiTableEntry = _context25.sent;\n                  topAggsPromise = multiTableEntry.getTopAggs(options);\n                  onCancel(function () {\n                    topAggsPromise.cancel();\n                  });\n                  topAggsPromise.then(resolve)[\"catch\"](reject);\n\n                case 6:\n                case \"end\":\n                  return _context25.stop();\n              }\n            }\n          }, _callee25);\n        }));\n\n        return function (_x48, _x49, _x50) {\n          return _ref19.apply(this, arguments);\n        };\n      }());\n      return applyCancellable(promise);\n    }\n    /**\n     * Gets the top filters for the entry if it's a table or view. It will fetch it if not cached or if the refresh option is set.\n     *\n     * @return {CancellableJqPromise}\n     */\n\n  }, {\n    key: \"getTopFilters\",\n    value: function getTopFilters(options) {\n      var _this20 = this;\n\n      var promise = new CancellablePromise( /*#__PURE__*/function () {\n        var _ref20 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(resolve, reject, onCancel) {\n          var multiTableEntry, topFiltersPromise;\n          return regeneratorRuntime.wrap(function _callee26$(_context26) {\n            while (1) {\n              switch (_context26.prev = _context26.next) {\n                case 0:\n                  _context26.next = 2;\n                  return getMultiTableEntry(_this20);\n\n                case 2:\n                  multiTableEntry = _context26.sent;\n                  topFiltersPromise = multiTableEntry.getTopFilters(options);\n                  onCancel(function () {\n                    topFiltersPromise.cancel();\n                  });\n                  topFiltersPromise.then(resolve)[\"catch\"](reject);\n\n                case 6:\n                case \"end\":\n                  return _context26.stop();\n              }\n            }\n          }, _callee26);\n        }));\n\n        return function (_x51, _x52, _x53) {\n          return _ref20.apply(this, arguments);\n        };\n      }());\n      return applyCancellable(promise);\n    }\n    /**\n     * Gets the top joins for the entry if it's a table or view. It will fetch it if not cached or if the refresh option is set.\n     */\n\n  }, {\n    key: \"getTopJoins\",\n    value: function getTopJoins(options) {\n      var _this21 = this;\n\n      var promise = new CancellablePromise( /*#__PURE__*/function () {\n        var _ref21 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(resolve, reject, onCancel) {\n          var multiTableEntry, topJoinsPromise;\n          return regeneratorRuntime.wrap(function _callee27$(_context27) {\n            while (1) {\n              switch (_context27.prev = _context27.next) {\n                case 0:\n                  _context27.next = 2;\n                  return getMultiTableEntry(_this21);\n\n                case 2:\n                  multiTableEntry = _context27.sent;\n                  topJoinsPromise = multiTableEntry.getTopJoins(options);\n                  onCancel(function () {\n                    topJoinsPromise.cancel();\n                  });\n                  topJoinsPromise.then(resolve)[\"catch\"](reject);\n\n                case 6:\n                case \"end\":\n                  return _context27.stop();\n              }\n            }\n          }, _callee27);\n        }));\n\n        return function (_x54, _x55, _x56) {\n          return _ref21.apply(this, arguments);\n        };\n      }());\n      return applyCancellable(promise);\n    }\n  }]);\n\n  return DataCatalogEntry;\n}();\n\nexport { DataCatalogEntry as default };","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport localforage from 'localforage';\nimport { fetchAllNavigatorTags } from \"./api\";\nimport { DataCatalog } from \"./dataCatalog\";\nvar STORAGE_POSTFIX = window.LOGGED_USERNAME;\nvar DATA_CATALOG_VERSION = 5;\nvar NAV_TAGS_STORE_ID = 'hue.dataCatalog.allNavTags';\n\nvar GeneralDataCatalog = /*#__PURE__*/function () {\n  function GeneralDataCatalog() {\n    _classCallCheck(this, GeneralDataCatalog);\n\n    this.store = void 0;\n    this.allNavigatorTagsPromise = void 0;\n    this.store = localforage.createInstance({\n      name: 'HueDataCatalog_' + STORAGE_POSTFIX\n    });\n  }\n\n  _createClass(GeneralDataCatalog, [{\n    key: \"getAllNavigatorTags\",\n    value: function () {\n      var _getAllNavigatorTags = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(options) {\n        var _this = this;\n\n        var ttl;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(this.allNavigatorTagsPromise && DataCatalog.cacheEnabled() && (!options || !options.refreshCache))) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", this.allNavigatorTagsPromise);\n\n              case 2:\n                if (window.HAS_CATALOG) {\n                  _context.next = 4;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", {});\n\n              case 4:\n                ttl = window.CACHEABLE_TTL || {};\n                this.allNavigatorTagsPromise = new Promise(function (resolve, reject) {\n                  var reloadAllTags = function reloadAllTags() {\n                    fetchAllNavigatorTags({\n                      silenceErrors: options && options.silenceErrors\n                    }).then(function (allTags) {\n                      resolve(allTags);\n\n                      if (ttl[\"default\"] && ttl[\"default\"] > 0) {\n                        _this.store.setItem(NAV_TAGS_STORE_ID, {\n                          allTags: allTags,\n                          hueTimestamp: Date.now(),\n                          version: DATA_CATALOG_VERSION\n                        });\n                      }\n                    })[\"catch\"](reject);\n                  };\n\n                  if (ttl[\"default\"] && ttl[\"default\"] > 0 && DataCatalog.cacheEnabled() && (!options || !options.refreshCache)) {\n                    _this.store.getItem(NAV_TAGS_STORE_ID).then(function (storeEntry) {\n                      if (storeEntry && storeEntry.version === DATA_CATALOG_VERSION && ttl[\"default\"] && (!storeEntry.hueTimestamp || Date.now() - storeEntry.hueTimestamp < ttl[\"default\"])) {\n                        resolve(storeEntry.allTags);\n                      } else {\n                        reloadAllTags();\n                      }\n                    })[\"catch\"](reloadAllTags);\n                  } else {\n                    reloadAllTags();\n                  }\n                });\n                return _context.abrupt(\"return\", this.allNavigatorTagsPromise);\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getAllNavigatorTags(_x) {\n        return _getAllNavigatorTags.apply(this, arguments);\n      }\n\n      return getAllNavigatorTags;\n    }()\n  }, {\n    key: \"updateAllNavigatorTags\",\n    value: function () {\n      var _updateAllNavigatorTags = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(tagsToAdd, tagsToRemove) {\n        var allTags;\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this.allNavigatorTagsPromise) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                _context2.next = 3;\n                return this.allNavigatorTagsPromise;\n\n              case 3:\n                allTags = _context2.sent;\n                tagsToAdd.forEach(function (newTag) {\n                  if (!allTags[newTag]) {\n                    allTags[newTag] = 0;\n                  }\n\n                  allTags[newTag]++;\n                });\n                tagsToRemove.forEach(function (removedTag) {\n                  if (!allTags[removedTag]) {\n                    allTags[removedTag]--;\n\n                    if (allTags[removedTag] === 0) {\n                      delete allTags[removedTag];\n                    }\n                  }\n                });\n                _context2.next = 8;\n                return this.store.setItem(NAV_TAGS_STORE_ID, {\n                  allTags: allTags,\n                  hueTimestamp: Date.now(),\n                  version: DATA_CATALOG_VERSION\n                });\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function updateAllNavigatorTags(_x2, _x3) {\n        return _updateAllNavigatorTags.apply(this, arguments);\n      }\n\n      return updateAllNavigatorTags;\n    }()\n  }]);\n\n  return GeneralDataCatalog;\n}();\n\nexport { GeneralDataCatalog as default };","function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { DataCatalog } from \"./dataCatalog\";\nimport { CancellablePromise } from 'api/cancellablePromise';\nimport { applyCancellable } from 'catalog/catalogUtils';\nimport noop from 'utils/timing/noop';\n\nvar fetchAndSave = function fetchAndSave(sqlAnalyzerFunction, setFunction, entry, apiOptions) {\n  var promise = sqlAnalyzerFunction({\n    paths: entry.paths,\n    // Set for MultiTableEntry\n    silenceErrors: apiOptions && apiOptions.silenceErrors\n  });\n  promise.then(function (data) {\n    setFunction(data);\n    entry.saveLater();\n  })[\"catch\"](noop);\n  return promise;\n};\n/**\n * Helper function to reload a SQL Analyzer multi table attribute, like topAggs or topFilters\n */\n\n\nvar genericSqlAnalyzerReload = function genericSqlAnalyzerReload(multiTableEntry, options, promiseSetter, dataAttributeSetter, sqlAnalyzerFunction) {\n  var promise = new CancellablePromise(function (resolve, reject, onCancel) {\n    if (!multiTableEntry.dataCatalog.canHaveSqlAnalyzerMeta()) {\n      reject();\n      return;\n    }\n\n    var fetchPromise = fetchAndSave(sqlAnalyzerFunction, dataAttributeSetter, multiTableEntry, options);\n    onCancel(function () {\n      if (fetchPromise.cancel) {\n        fetchPromise.cancel();\n      }\n    });\n    fetchPromise.then(resolve)[\"catch\"](function (err) {\n      if (fetchPromise.cancelled) {\n        promiseSetter(undefined);\n      }\n\n      reject(err);\n    });\n  });\n  promiseSetter(promise);\n  return promise;\n};\n/**\n * Helper function to get a SQL Analyzer multi table attribute, like topAggs or topFilters\n */\n\n\nvar genericSqlAnalyzerGet = function genericSqlAnalyzerGet(multiTableEntry, options, promiseSetter, promiseGetter, dataAttributeSetter, apiHelperFunction) {\n  var promise = promiseGetter();\n\n  if (DataCatalog.cacheEnabled() && options && options.cachedOnly) {\n    return promise && applyCancellable(promise) || CancellablePromise.reject();\n  }\n\n  if (!promise || !DataCatalog.cacheEnabled() || options && options.refreshCache) {\n    promise = genericSqlAnalyzerReload(multiTableEntry, options, promiseSetter, dataAttributeSetter, apiHelperFunction);\n  }\n\n  return applyCancellable(promise, options);\n};\n\nvar MultiTableEntry = /*#__PURE__*/function () {\n  function MultiTableEntry(options) {\n    _classCallCheck(this, MultiTableEntry);\n\n    this.dataCatalog = void 0;\n    this.identifier = void 0;\n    this.paths = void 0;\n    this.saveTimeout = -1;\n    this.topAggs = void 0;\n    this.topAggsPromise = void 0;\n    this.topColumns = void 0;\n    this.topColumnsPromise = void 0;\n    this.topFilters = void 0;\n    this.topFiltersPromise = void 0;\n    this.topJoins = void 0;\n    this.topJoinsPromise = void 0;\n    this.identifier = options.identifier;\n    this.dataCatalog = options.dataCatalog;\n    this.paths = options.paths;\n  }\n  /**\n   * Save the multi table entry to cache\n   *\n   * @return {Promise}\n   */\n\n\n  _createClass(MultiTableEntry, [{\n    key: \"save\",\n    value: function save() {\n      window.clearTimeout(this.saveTimeout);\n      return this.dataCatalog.persistMultiTableEntry(this);\n    }\n    /**\n     * Save the multi table entry at a later point of time\n     */\n\n  }, {\n    key: \"saveLater\",\n    value: function saveLater() {\n      var _this = this;\n\n      var ttl = window.CACHEABLE_TTL;\n\n      if (ttl && ttl[\"default\"] && ttl[\"default\"] > 0) {\n        window.clearTimeout(this.saveTimeout);\n        this.saveTimeout = window.setTimeout(function () {\n          _this.save()[\"catch\"]();\n        }, 1000);\n      }\n    }\n    /**\n     * Returns the dialect of this entry.\n     */\n\n  }, {\n    key: \"getDialect\",\n    value: function getDialect() {\n      return this.getConnector().dialect || this.getConnector().id; // .id for editor v1\n    }\n    /**\n     * Returns the connector for this entry\n     */\n\n  }, {\n    key: \"getConnector\",\n    value: function getConnector() {\n      return this.dataCatalog.connector;\n    }\n    /**\n     * Gets the top aggregate UDFs for the entry. It will fetch it if not cached or if the refresh option is set.\n     */\n\n  }, {\n    key: \"getTopAggs\",\n    value: function getTopAggs(options) {\n      var _this2 = this;\n\n      return genericSqlAnalyzerGet(this, options, function (promise) {\n        _this2.topAggsPromise = promise;\n      }, function () {\n        return _this2.topAggsPromise;\n      }, function (val) {\n        _this2.topAggs = val;\n      }, options.sqlAnalyzer.fetchTopAggs.bind(options.sqlAnalyzer));\n    }\n    /**\n     * Gets the top columns for the entry. It will fetch it if not cached or if the refresh option is set.\n     */\n\n  }, {\n    key: \"getTopColumns\",\n    value: function getTopColumns(options) {\n      var _this3 = this;\n\n      return genericSqlAnalyzerGet(this, options, function (promise) {\n        _this3.topColumnsPromise = promise;\n      }, function () {\n        return _this3.topColumnsPromise;\n      }, function (val) {\n        _this3.topColumns = val;\n      }, options.sqlAnalyzer.fetchTopColumns.bind(options.sqlAnalyzer));\n    }\n    /**\n     * Gets the top filters for the entry. It will fetch it if not cached or if the refresh option is set.\n     */\n\n  }, {\n    key: \"getTopFilters\",\n    value: function getTopFilters(options) {\n      var _this4 = this;\n\n      return genericSqlAnalyzerGet(this, options, function (promise) {\n        _this4.topFiltersPromise = promise;\n      }, function () {\n        return _this4.topFiltersPromise;\n      }, function (val) {\n        _this4.topFilters = val;\n      }, options.sqlAnalyzer.fetchTopFilters.bind(options.sqlAnalyzer));\n    }\n    /**\n     * Gets the top joins for the entry. It will fetch it if not cached or if the refresh option is set.\n     */\n\n  }, {\n    key: \"getTopJoins\",\n    value: function getTopJoins(options) {\n      var _this5 = this;\n\n      return genericSqlAnalyzerGet(this, options, function (promise) {\n        _this5.topJoinsPromise = promise;\n      }, function () {\n        return _this5.topJoinsPromise;\n      }, function (val) {\n        _this5.topJoins = val;\n      }, options.sqlAnalyzer.fetchTopJoins.bind(options.sqlAnalyzer));\n    }\n  }]);\n\n  return MultiTableEntry;\n}();\n\nexport default MultiTableEntry;","function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { extractErrorMessage, post, successResponseIsError } from 'api/utils';\n\n/**\n * Fetches the popularity for various aspects of the given tables\n */\nvar genericSqlAnalyzerMultiTableFetch = function genericSqlAnalyzerMultiTableFetch(_ref, url) {\n  var silenceErrors = _ref.silenceErrors,\n      paths = _ref.paths,\n      connector = _ref.connector;\n  var dbTables = new Set();\n  paths.forEach(function (path) {\n    dbTables.add(path.join('.'));\n  });\n  var data = {\n    connector: JSON.stringify(connector),\n    dbTables: JSON.stringify(_toConsumableArray(dbTables.values()))\n  };\n  return post(url, data, {\n    silenceErrors: silenceErrors,\n    handleSuccess: function handleSuccess(response, resolve, reject) {\n      if (successResponseIsError(response)) {\n        reject(extractErrorMessage(response));\n      } else {\n        response.hueTimestamp = Date.now();\n        resolve(response);\n      }\n    }\n  });\n};\n\nvar COMPATIBILITY_URL = '/api/optimizer/query_compatibility';\nvar PREDICT_URL = '/api/optimizer/predict';\nvar RISK_URL = '/api/optimizer/query_risk/';\nvar SIMILARITY_URL = '/api/optimizer/similar_queries';\nvar TOP_AGGS_URL = '/api/optimizer/top_aggs';\nvar TOP_COLUMNS_URL = '/api/optimizer/top_columns';\nvar TOP_FILTERS_URL = '/api/optimizer/top_filters';\nvar TOP_JOINS_URL = '/api/optimizer/top_joins';\nvar TOP_TABLES_URL = '/api/optimizer/top_tables';\nvar TABLE_DETAILS_URL = '/api/optimizer/table_details';\n\nvar ApiSqlAnalyzer = /*#__PURE__*/function () {\n  function ApiSqlAnalyzer(connector) {\n    _classCallCheck(this, ApiSqlAnalyzer);\n\n    this.connector = void 0;\n    this.connector = connector;\n  }\n\n  _createClass(ApiSqlAnalyzer, [{\n    key: \"analyzeCompatibility\",\n    value: function analyzeCompatibility(_ref2) {\n      var notebookJson = _ref2.notebookJson,\n          snippetJson = _ref2.snippetJson,\n          sourcePlatform = _ref2.sourcePlatform,\n          targetPlatform = _ref2.targetPlatform,\n          silenceErrors = _ref2.silenceErrors;\n      return post(COMPATIBILITY_URL, {\n        connector: JSON.stringify(this.connector),\n        notebook: notebookJson,\n        snippet: snippetJson,\n        sourcePlatform: sourcePlatform,\n        targetPlatform: targetPlatform\n      }, {\n        silenceErrors: silenceErrors\n      });\n    }\n  }, {\n    key: \"analyzeRisk\",\n    value: function analyzeRisk(_ref3) {\n      var notebookJson = _ref3.notebookJson,\n          snippetJson = _ref3.snippetJson,\n          silenceErrors = _ref3.silenceErrors;\n      return post(RISK_URL, {\n        connector: JSON.stringify(this.connector),\n        notebook: notebookJson,\n        snippet: snippetJson\n      }, {\n        silenceErrors: silenceErrors\n      });\n    }\n  }, {\n    key: \"analyzeSimilarity\",\n    value: function analyzeSimilarity(_ref4) {\n      var notebookJson = _ref4.notebookJson,\n          snippetJson = _ref4.snippetJson,\n          sourcePlatform = _ref4.sourcePlatform,\n          silenceErrors = _ref4.silenceErrors;\n      return post(SIMILARITY_URL, {\n        connector: JSON.stringify(this.connector),\n        notebook: notebookJson,\n        snippet: snippetJson,\n        sourcePlatform: sourcePlatform\n      }, {\n        silenceErrors: silenceErrors\n      });\n    }\n  }, {\n    key: \"fetchPopularity\",\n    value: function fetchPopularity(_ref5) {\n      var paths = _ref5.paths,\n          silenceErrors = _ref5.silenceErrors;\n      var url, data;\n\n      if (paths.length === 1 && paths[0].length === 1) {\n        url = TOP_TABLES_URL;\n        data = {\n          connector: JSON.stringify(this.connector),\n          database: paths[0][0]\n        };\n      } else {\n        url = TOP_COLUMNS_URL;\n        data = {\n          connector: JSON.stringify(this.connector),\n          dbTables: JSON.stringify(paths.map(function (path) {\n            return path.join('.');\n          }))\n        };\n      }\n\n      return post(url, data, {\n        silenceErrors: silenceErrors,\n        handleSuccess: function handleSuccess(response, resolve, reject) {\n          if (successResponseIsError(response)) {\n            reject(extractErrorMessage(response));\n          } else {\n            response.hueTimestamp = Date.now();\n            resolve(response);\n          }\n        }\n      });\n    }\n  }, {\n    key: \"fetchTopAggs\",\n    value: function fetchTopAggs(options) {\n      return genericSqlAnalyzerMultiTableFetch(_objectSpread(_objectSpread({}, options), {}, {\n        connector: this.connector\n      }), TOP_AGGS_URL);\n    }\n  }, {\n    key: \"fetchTopColumns\",\n    value: function fetchTopColumns(options) {\n      return genericSqlAnalyzerMultiTableFetch(_objectSpread(_objectSpread({}, options), {}, {\n        connector: this.connector\n      }), TOP_COLUMNS_URL);\n    }\n  }, {\n    key: \"fetchTopFilters\",\n    value: function fetchTopFilters(options) {\n      return genericSqlAnalyzerMultiTableFetch(_objectSpread(_objectSpread({}, options), {}, {\n        connector: this.connector\n      }), TOP_FILTERS_URL);\n    }\n  }, {\n    key: \"fetchTopJoins\",\n    value: function fetchTopJoins(options) {\n      return genericSqlAnalyzerMultiTableFetch(_objectSpread(_objectSpread({}, options), {}, {\n        connector: this.connector\n      }), TOP_JOINS_URL);\n    }\n  }, {\n    key: \"fetchSqlAnalyzerMeta\",\n    value: function fetchSqlAnalyzerMeta(_ref6) {\n      var path = _ref6.path,\n          silenceErrors = _ref6.silenceErrors;\n      return post(TABLE_DETAILS_URL, {\n        connector: JSON.stringify(this.connector),\n        databaseName: path[0],\n        tableName: path[1]\n      }, {\n        silenceErrors: silenceErrors,\n        handleSuccess: function handleSuccess(response, resolve, reject) {\n          if (response.status === 0 && response.details) {\n            response.details.hueTimestamp = Date.now();\n            resolve(response.details);\n          }\n\n          reject(extractErrorMessage(response));\n        }\n      });\n    }\n  }, {\n    key: \"predict\",\n    value: function predict(_ref7) {\n      var beforeCursor = _ref7.beforeCursor,\n          afterCursor = _ref7.afterCursor;\n      return post(PREDICT_URL, {\n        connector: JSON.stringify(this.connector),\n        beforeCursor: beforeCursor,\n        afterCursor: afterCursor\n      }, {\n        silenceErrors: true,\n        handleSuccess: function handleSuccess(response, resolve) {\n          resolve(response);\n        }\n      });\n    }\n  }]);\n\n  return ApiSqlAnalyzer;\n}();\n\nexport { ApiSqlAnalyzer as default };","function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { CancellablePromise } from 'api/cancellablePromise';\nimport { getNamespaces } from 'catalog/contextCatalog';\nimport ApiSqlAnalyzer from \"./ApiSqlAnalyzer\";\nimport { SqlAnalyzerMode } from 'catalog/analyzer/types';\nimport dataCatalog from 'catalog/dataCatalog';\nimport sqlParserRepository from 'parse/sql/sqlParserRepository';\nimport I18n from \"../../utils/i18n\";\n\nvar CombinedSqlAnalyser = /*#__PURE__*/function () {\n  function CombinedSqlAnalyser(connector) {\n    _classCallCheck(this, CombinedSqlAnalyser);\n\n    this.apiAnalyzer = void 0;\n    this.connector = void 0;\n    this.apiAnalyzer = new ApiSqlAnalyzer(connector);\n    this.connector = connector;\n  }\n\n  _createClass(CombinedSqlAnalyser, [{\n    key: \"analyzeRisk\",\n    value: function analyzeRisk(options) {\n      var _this = this;\n\n      return new CancellablePromise( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(resolve, reject, onCancel) {\n          var apiPromise, snippet, missingLimit, hints, isSelectStar, apiResponse;\n          return regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  if (_this.connector.dialect) {\n                    _context.next = 3;\n                    break;\n                  }\n\n                  reject();\n                  return _context.abrupt(\"return\");\n\n                case 3:\n                  apiPromise = _this.apiAnalyzer.analyzeRisk(_objectSpread(_objectSpread({}, options), {}, {\n                    silenceErrors: true\n                  }));\n                  onCancel(function () {\n                    apiPromise.cancel();\n                  });\n                  snippet = JSON.parse(options.snippetJson);\n                  _context.next = 8;\n                  return _this.checkMissingLimit(snippet.statement, _this.connector.dialect);\n\n                case 8:\n                  missingLimit = _context.sent;\n                  hints = missingLimit ? [{\n                    riskTables: [],\n                    riskAnalysis: I18n('Query has no limit'),\n                    riskId: 17,\n                    risk: 'low',\n                    riskRecommendation: I18n('Append a limit clause to reduce the size of the result set')\n                  }] : [];\n                  _context.next = 12;\n                  return _this.checkSelectStar(snippet.statement, _this.connector.dialect);\n\n                case 12:\n                  isSelectStar = _context.sent;\n\n                  if (isSelectStar) {\n                    hints.push({\n                      riskTables: [],\n                      riskAnalysis: I18n('Query doing a SELECT *'),\n                      // Could be triggered only if column number > 10 (todo in Validator API)\n                      riskId: 18,\n                      risk: 'low',\n                      riskRecommendation: I18n('Select only a subset of columns instead of all of them')\n                    });\n                  }\n\n                  _context.prev = 14;\n                  _context.next = 17;\n                  return apiPromise;\n\n                case 17:\n                  apiResponse = _context.sent;\n\n                  if (apiResponse.query_complexity && apiResponse.query_complexity.hints) {\n                    hints.push.apply(hints, _toConsumableArray(apiResponse.query_complexity.hints));\n                  }\n\n                  _context.next = 23;\n                  break;\n\n                case 21:\n                  _context.prev = 21;\n                  _context.t0 = _context[\"catch\"](14);\n\n                case 23:\n                  resolve({\n                    status: 0,\n                    message: '',\n                    query_complexity: {\n                      hints: hints,\n                      noStats: true,\n                      noDDL: false\n                    }\n                  });\n\n                case 24:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, null, [[14, 21]]);\n        }));\n\n        return function (_x, _x2, _x3) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    }\n  }, {\n    key: \"checkMissingLimit\",\n    value: function () {\n      var _checkMissingLimit = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(statement, dialect) {\n        var autocompleter, parsedStatement;\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return sqlParserRepository.getAutocompleteParser(dialect);\n\n              case 2:\n                autocompleter = _context2.sent;\n                _context2.prev = 3;\n                parsedStatement = autocompleter.parseSql(statement + ' ', '');\n                _context2.next = 10;\n                break;\n\n              case 7:\n                _context2.prev = 7;\n                _context2.t0 = _context2[\"catch\"](3);\n                return _context2.abrupt(\"return\", false);\n\n              case 10:\n                return _context2.abrupt(\"return\", parsedStatement.locations.some(function (location) {\n                  return location.type === 'statementType' && location.identifier === 'SELECT';\n                }) && parsedStatement.locations.some(function (location) {\n                  return location.type === 'table';\n                }) && parsedStatement.locations.some(function (location) {\n                  return location.type === 'limitClause' && location.missing;\n                }));\n\n              case 11:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[3, 7]]);\n      }));\n\n      function checkMissingLimit(_x4, _x5) {\n        return _checkMissingLimit.apply(this, arguments);\n      }\n\n      return checkMissingLimit;\n    }()\n  }, {\n    key: \"checkSelectStar\",\n    value: function () {\n      var _checkSelectStar = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(statement, dialect) {\n        var autocompleter, parsedStatement;\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return sqlParserRepository.getAutocompleteParser(dialect);\n\n              case 2:\n                autocompleter = _context3.sent;\n                _context3.prev = 3;\n                parsedStatement = autocompleter.parseSql(statement + ' ', '');\n                _context3.next = 10;\n                break;\n\n              case 7:\n                _context3.prev = 7;\n                _context3.t0 = _context3[\"catch\"](3);\n                return _context3.abrupt(\"return\", false);\n\n              case 10:\n                return _context3.abrupt(\"return\", parsedStatement.locations.some(function (location) {\n                  return location.type === 'statementType' && location.identifier === 'SELECT';\n                }) && parsedStatement.locations.some(function (location) {\n                  return location.type === 'selectList' && !location.missing;\n                }) && parsedStatement.locations.some(function (location) {\n                  return location.type === 'asterisk';\n                }));\n\n              case 11:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, null, [[3, 7]]);\n      }));\n\n      function checkSelectStar(_x6, _x7) {\n        return _checkSelectStar.apply(this, arguments);\n      }\n\n      return checkSelectStar;\n    }()\n  }, {\n    key: \"fetchTopJoins\",\n    value: function fetchTopJoins(options) {\n      var _this2 = this;\n\n      var apiPromise = this.apiAnalyzer.fetchTopJoins(options);\n      var path = options.paths[0].join('.');\n      return new CancellablePromise(function (resolve, reject, onCancel) {\n        getNamespaces(_objectSpread({\n          connector: _this2.connector\n        }, options)).then( /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(result) {\n            var entry, sourceMetaPromise, sourceMeta, values, apiResponse;\n            return regeneratorRuntime.wrap(function _callee4$(_context4) {\n              while (1) {\n                switch (_context4.prev = _context4.next) {\n                  case 0:\n                    if (!(!result.namespaces.length || !result.namespaces[0].computes.length)) {\n                      _context4.next = 4;\n                      break;\n                    }\n\n                    reject('No namespace or compute found');\n                    console.warn(result);\n                    return _context4.abrupt(\"return\");\n\n                  case 4:\n                    _context4.next = 6;\n                    return dataCatalog.getEntry({\n                      connector: _this2.connector,\n                      path: path,\n                      namespace: result.namespaces[0],\n                      compute: result.namespaces[0].computes[0]\n                    });\n\n                  case 6:\n                    entry = _context4.sent;\n                    sourceMetaPromise = entry.getSourceMeta(options);\n                    onCancel(function () {\n                      apiPromise.cancel();\n                      sourceMetaPromise.cancel();\n                    });\n                    _context4.prev = 9;\n                    _context4.next = 12;\n                    return sourceMetaPromise;\n\n                  case 12:\n                    sourceMeta = _context4.sent;\n                    values = (sourceMeta.foreign_keys || []).map(function (key) {\n                      return {\n                        totalTableCount: 22,\n                        totalQueryCount: 3,\n                        joinCols: [{\n                          columns: [path + '.' + key.name, key.to]\n                        }],\n                        tables: [path].concat(key.to.split('.', 2).join('.')),\n                        joinType: 'join'\n                      };\n                    });\n                    _context4.prev = 14;\n                    _context4.next = 17;\n                    return apiPromise;\n\n                  case 17:\n                    apiResponse = _context4.sent;\n                    values.push.apply(values, _toConsumableArray(apiResponse.values));\n                    _context4.next = 23;\n                    break;\n\n                  case 21:\n                    _context4.prev = 21;\n                    _context4.t0 = _context4[\"catch\"](14);\n\n                  case 23:\n                    resolve({\n                      values: values\n                    });\n                    _context4.next = 29;\n                    break;\n\n                  case 26:\n                    _context4.prev = 26;\n                    _context4.t1 = _context4[\"catch\"](9);\n                    reject(_context4.t1);\n\n                  case 29:\n                  case \"end\":\n                    return _context4.stop();\n                }\n              }\n            }, _callee4, null, [[9, 26], [14, 21]]);\n          }));\n\n          return function (_x8) {\n            return _ref2.apply(this, arguments);\n          };\n        }())[\"catch\"](reject);\n      });\n    }\n  }, {\n    key: \"analyzeCompatibility\",\n    value: function analyzeCompatibility(options) {\n      if (window.SQL_ANALYZER_MODE === SqlAnalyzerMode.api) {\n        return this.apiAnalyzer.analyzeCompatibility(options);\n      }\n\n      return CancellablePromise.reject('analyzeCompatibility is not Implemented');\n    }\n  }, {\n    key: \"analyzeSimilarity\",\n    value: function analyzeSimilarity(options) {\n      if (window.SQL_ANALYZER_MODE === SqlAnalyzerMode.api) {\n        return this.apiAnalyzer.analyzeSimilarity(options);\n      }\n\n      return CancellablePromise.reject('analyzeSimilarity is not Implemented');\n    }\n  }, {\n    key: \"fetchSqlAnalyzerMeta\",\n    value: function fetchSqlAnalyzerMeta(options) {\n      if (window.SQL_ANALYZER_MODE === SqlAnalyzerMode.api) {\n        return this.apiAnalyzer.fetchSqlAnalyzerMeta(options);\n      }\n\n      return CancellablePromise.reject('fetchSqlAnalyzerMeta is not Implemented');\n    }\n  }, {\n    key: \"fetchPopularity\",\n    value: function fetchPopularity(options) {\n      if (window.SQL_ANALYZER_MODE === SqlAnalyzerMode.api) {\n        return this.apiAnalyzer.fetchPopularity(options);\n      }\n\n      return CancellablePromise.reject('fetchPopularity is not Implemented');\n    }\n  }, {\n    key: \"fetchTopAggs\",\n    value: function fetchTopAggs(options) {\n      if (window.SQL_ANALYZER_MODE === SqlAnalyzerMode.api) {\n        return this.apiAnalyzer.fetchTopAggs(options);\n      }\n\n      return CancellablePromise.reject('fetchTopAggs is not Implemented');\n    }\n  }, {\n    key: \"fetchTopColumns\",\n    value: function fetchTopColumns(options) {\n      if (window.SQL_ANALYZER_MODE === SqlAnalyzerMode.api) {\n        return this.apiAnalyzer.fetchTopColumns(options);\n      }\n\n      return CancellablePromise.reject('fetchTopColumns is not Implemented');\n    }\n  }, {\n    key: \"fetchTopFilters\",\n    value: function fetchTopFilters(options) {\n      if (window.SQL_ANALYZER_MODE === SqlAnalyzerMode.api) {\n        return this.apiAnalyzer.fetchTopFilters(options);\n      }\n\n      return CancellablePromise.reject('fetchTopFilters is not Implemented');\n    }\n  }, {\n    key: \"predict\",\n    value: function predict(options) {\n      return this.apiAnalyzer.predict(options);\n    }\n  }]);\n\n  return CombinedSqlAnalyser;\n}();\n\nexport { CombinedSqlAnalyser as default };","function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { CancellablePromise } from 'api/cancellablePromise';\n\nvar NoopSqlAnalyzer = /*#__PURE__*/function () {\n  function NoopSqlAnalyzer() {\n    _classCallCheck(this, NoopSqlAnalyzer);\n  }\n\n  _createClass(NoopSqlAnalyzer, [{\n    key: \"analyzeCompatibility\",\n    value: // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    function analyzeCompatibility(options) {\n      return CancellablePromise.reject('analyzeCompatibility is not Implemented');\n    } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"analyzeRisk\",\n    value: function analyzeRisk(options) {\n      return CancellablePromise.reject('analyzeRisk is not Implemented');\n    } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"analyzeSimilarity\",\n    value: function analyzeSimilarity(options) {\n      return CancellablePromise.reject('analyzeSimilarity is not Implemented');\n    } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"fetchSqlAnalyzerMeta\",\n    value: function fetchSqlAnalyzerMeta(options) {\n      return CancellablePromise.reject('fetchSqlAnalyzerMeta is not Implemented');\n    } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"fetchPopularity\",\n    value: function fetchPopularity(options) {\n      return CancellablePromise.reject('analyzeCompatibility is not Implemented');\n    } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"fetchTopAggs\",\n    value: function fetchTopAggs(options) {\n      return CancellablePromise.reject('fetchTopAggs is not Implemented');\n    } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"fetchTopColumns\",\n    value: function fetchTopColumns(options) {\n      return CancellablePromise.reject('fetchTopColumns is not Implemented');\n    } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"fetchTopFilters\",\n    value: function fetchTopFilters(options) {\n      return CancellablePromise.reject('fetchTopFilters is not Implemented');\n    } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"fetchTopJoins\",\n    value: function fetchTopJoins(options) {\n      return CancellablePromise.reject('fetchTopJoins is not Implemented');\n    } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"predict\",\n    value: function predict(options) {\n      return CancellablePromise.reject('predict is not Implemented');\n    }\n  }]);\n\n  return NoopSqlAnalyzer;\n}();\n\nexport { NoopSqlAnalyzer as default };","// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport CombinedSqlAnalyser from \"./CombinedSqlAnalyser\";\nimport NoopSqlAnalyzer from \"./NoopSqlAnalyzer\";\nvar sqlAnalyzerInstances = {};\n\nvar createSqlAnalyzer = function createSqlAnalyzer(connector) {\n  if (connector.optimizer === 'api') {\n    return new CombinedSqlAnalyser(connector);\n  }\n\n  return new NoopSqlAnalyzer();\n};\n\nvar sqlAnalyzerRepository = {\n  getSqlAnalyzer: function getSqlAnalyzer(connector) {\n    var sqlAnalyzer = sqlAnalyzerInstances[connector.id];\n\n    if (!sqlAnalyzer) {\n      sqlAnalyzer = createSqlAnalyzer(connector);\n      sqlAnalyzerInstances[connector.id] = sqlAnalyzer;\n    }\n\n    return sqlAnalyzer;\n  }\n};\nexport default sqlAnalyzerRepository;","// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nexport var SqlAnalyzerMode;\n\n(function (SqlAnalyzerMode) {\n  SqlAnalyzerMode[\"local\"] = \"local\";\n  SqlAnalyzerMode[\"api\"] = \"api\";\n  SqlAnalyzerMode[\"off\"] = \"off\";\n})(SqlAnalyzerMode || (SqlAnalyzerMode = {}));","function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { CancellablePromise } from 'api/cancellablePromise';\nimport { extractErrorMessage, get, post, successResponseIsError } from 'api/utils';\nimport { closeSession } from 'apps/editor/execution/api';\nimport \"../utils/json.bigDataParse\";\nimport sleep from 'utils/timing/sleep';\nimport UUID from 'utils/string/UUID';\nvar ADD_TAGS_URL = '/metadata/api/catalog/add_tags';\nvar AUTOCOMPLETE_URL_PREFIX = '/api/editor/autocomplete/';\nvar CANCEL_STATEMENT_URL = '/api/editor/cancel_statement';\nvar CHECK_STATUS_URL = '/api/editor/check_status';\nvar DELETE_TAGS_URL = '/metadata/api/catalog/delete_tags';\nvar DESCRIBE_URL = '/api/editor/describe/';\nvar FETCH_RESULT_DATA_URL = '/api/editor/fetch_result_data';\nvar FIND_ENTITY_URL = '/metadata/api/catalog/find_entity';\nvar LIST_TAGS_URL = '/metadata/api/catalog/list_tags';\nvar METASTORE_TABLE_URL_PREFIX = '/metastore/table/';\nvar SAMPLE_URL_PREFIX = '/api/editor/sample/';\nvar SEARCH_URL = '/desktop/api/search/entities';\nvar UPDATE_PROPERTIES_URL = '/metadata/api/catalog/update_properties';\n\nvar getEntryUrlPath = function getEntryUrlPath(entry) {\n  return entry.path.join('/') + (entry.path.length ? '/' : '');\n};\n\nvar performAnalyze = function performAnalyze(_ref) {\n  var entry = _ref.entry,\n      silenceErrors = _ref.silenceErrors;\n\n  if (entry.isDatabase()) {\n    return CancellablePromise.resolve();\n  }\n\n  var cancelled = false;\n\n  var pollForAnalysis = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(url, delay) {\n      var analyzeResponse;\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return post(url, undefined, {\n                silenceErrors: silenceErrors\n              });\n\n            case 2:\n              analyzeResponse = _context.sent;\n\n              if (!cancelled) {\n                _context.next = 5;\n                break;\n              }\n\n              throw new Error('Cancelled');\n\n            case 5:\n              if (!(!analyzeResponse.isFailure && !analyzeResponse.isSuccess)) {\n                _context.next = 11;\n                break;\n              }\n\n              _context.next = 8;\n              return sleep(delay);\n\n            case 8:\n              return _context.abrupt(\"return\", pollForAnalysis(url, 1000));\n\n            case 11:\n              return _context.abrupt(\"return\", analyzeResponse);\n\n            case 12:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function pollForAnalysis(_x, _x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  return new CancellablePromise( /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(resolve, reject, onCancel) {\n      var analyzeResponse;\n      return regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              onCancel(function () {\n                cancelled = true;\n              });\n              _context2.prev = 1;\n              _context2.next = 4;\n              return post(\"/api/\".concat(entry.getConnector().id === 'hive' ? 'beeswax' : entry.getConnector().id, \"/analyze/\").concat(getEntryUrlPath(entry)), undefined, {\n                silenceErrors: silenceErrors\n              });\n\n            case 4:\n              analyzeResponse = _context2.sent;\n\n              if (!(!cancelled && analyzeResponse && analyzeResponse.status === 0 && analyzeResponse.watch_url)) {\n                _context2.next = 13;\n                break;\n              }\n\n              _context2.t0 = resolve;\n              _context2.next = 9;\n              return pollForAnalysis(analyzeResponse.watch_url, 500);\n\n            case 9:\n              _context2.t1 = _context2.sent;\n              (0, _context2.t0)(_context2.t1);\n              _context2.next = 14;\n              break;\n\n            case 13:\n              reject('Analyze failed');\n\n            case 14:\n              _context2.next = 19;\n              break;\n\n            case 16:\n              _context2.prev = 16;\n              _context2.t2 = _context2[\"catch\"](1);\n              reject(_context2.t2 || 'Analyze failed');\n\n            case 19:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[1, 16]]);\n    }));\n\n    return function (_x3, _x4, _x5) {\n      return _ref3.apply(this, arguments);\n    };\n  }());\n};\n\nexport var fetchDescribe = function fetchDescribe(_ref4) {\n  var entry = _ref4.entry,\n      silenceErrors = _ref4.silenceErrors,\n      refreshAnalysis = _ref4.refreshAnalysis;\n  return new CancellablePromise( /*#__PURE__*/function () {\n    var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(resolve, reject, onCancel) {\n      var analyzePromise, _entry$path, database, table, fields, url, describePromise;\n\n      return regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              if (!entry.isSource()) {\n                _context3.next = 3;\n                break;\n              }\n\n              reject('Describe is not possible on the source');\n              return _context3.abrupt(\"return\");\n\n            case 3:\n              if (!refreshAnalysis) {\n                _context3.next = 13;\n                break;\n              }\n\n              analyzePromise = performAnalyze({\n                entry: entry,\n                silenceErrors: silenceErrors\n              });\n              onCancel(analyzePromise.cancel.bind(analyzePromise));\n              _context3.prev = 6;\n              _context3.next = 9;\n              return analyzePromise;\n\n            case 9:\n              _context3.next = 13;\n              break;\n\n            case 11:\n              _context3.prev = 11;\n              _context3.t0 = _context3[\"catch\"](6);\n\n            case 13:\n              _entry$path = _toArray(entry.path), database = _entry$path[0], table = _entry$path[1], fields = _entry$path.slice(2);\n              url = \"\".concat(DESCRIBE_URL).concat(database);\n\n              if (table && fields.length) {\n                url += \"/\".concat(table, \"/stats/\").concat(fields.join('/'));\n              } else if (table) {\n                url += \"/\".concat(table, \"/\");\n              }\n\n              describePromise = post(url, {\n                format: 'json',\n                cluster: JSON.stringify(entry.compute),\n                source_type: entry.getConnector().id,\n                connector: JSON.stringify(entry.getConnector())\n              }, {\n                silenceErrors: silenceErrors,\n                handleSuccess: function handleSuccess(response, postResolve, postReject) {\n                  if (successResponseIsError(response)) {\n                    postReject(extractErrorMessage(response));\n                  } else {\n                    var adjustedResponse = response;\n                    adjustedResponse.hueTimestamp = Date.now();\n                    postResolve(adjustedResponse);\n                  }\n                }\n              });\n              _context3.prev = 17;\n              _context3.t1 = resolve;\n              _context3.next = 21;\n              return describePromise;\n\n            case 21:\n              _context3.t2 = _context3.sent;\n              (0, _context3.t1)(_context3.t2);\n              _context3.next = 28;\n              break;\n\n            case 25:\n              _context3.prev = 25;\n              _context3.t3 = _context3[\"catch\"](17);\n              reject(_context3.t3 || 'Describe failed');\n\n            case 28:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3, null, [[6, 11], [17, 25]]);\n    }));\n\n    return function (_x6, _x7, _x8) {\n      return _ref5.apply(this, arguments);\n    };\n  }());\n};\nexport var fetchClusters = function fetchClusters(connector, silenceErrors) {\n  return get(\"/desktop/api2/context/clusters/\".concat(connector.id), undefined, {\n    silenceErrors: silenceErrors\n  });\n};\nexport var fetchComputes = function fetchComputes(connector, silenceErrors) {\n  return get(\"/desktop/api2/context/computes/\".concat(connector.id), undefined, {\n    silenceErrors: silenceErrors\n  });\n};\nexport var fetchNamespaces = function fetchNamespaces(connector, silenceErrors) {\n  return get(\"/api/get_namespaces/\".concat(connector.id), undefined, {\n    silenceErrors: silenceErrors\n  });\n};\nexport var fetchNavigatorMetadata = function fetchNavigatorMetadata(_ref6) {\n  var entry = _ref6.entry,\n      silenceErrors = _ref6.silenceErrors;\n  var params = new URLSearchParams();\n\n  var _entry$path2 = _slicedToArray(entry.path, 3),\n      database = _entry$path2[0],\n      tableOrView = _entry$path2[1],\n      field = _entry$path2[2];\n\n  if (database && tableOrView && field) {\n    params.append('type', 'field');\n    params.append('database', database);\n    params.append('table', tableOrView);\n  } else if (database && tableOrView) {\n    params.append('type', entry.isView() ? 'view' : 'table');\n    params.append('database', database);\n  } else if (database) {\n    params.append('type', 'database');\n  } else {\n    return CancellablePromise.reject('Navigator metadata is not possible on the source');\n  }\n\n  params.append('name', entry.name);\n  return post(\"\".concat(FIND_ENTITY_URL, \"?\").concat(params), {\n    notebook: {},\n    snippet: JSON.stringify({\n      type: entry.getConnector().id,\n      source: 'data'\n    }),\n    cluster: entry.compute && JSON.stringify(entry.compute) || '\"\"'\n  }, {\n    silenceErrors: silenceErrors,\n    handleSuccess: function handleSuccess(response, resolve, reject) {\n      if (successResponseIsError(response)) {\n        reject(extractErrorMessage(response));\n      } else {\n        var adjustedResponse = response.entity || response;\n        adjustedResponse.hueTimestamp = Date.now();\n        resolve(adjustedResponse);\n      }\n    }\n  });\n};\nexport var fetchAllNavigatorTags = function fetchAllNavigatorTags(_ref7) {\n  var silenceErrors = _ref7.silenceErrors;\n  return post(LIST_TAGS_URL, undefined, {\n    silenceErrors: silenceErrors,\n    handleSuccess: function handleSuccess(response, resolve, reject) {\n      if (successResponseIsError(response)) {\n        reject(extractErrorMessage(response));\n      } else {\n        resolve(response.tags || {});\n      }\n    }\n  });\n};\nexport var fetchPartitions = function fetchPartitions(_ref8) {\n  var entry = _ref8.entry,\n      silenceErrors = _ref8.silenceErrors;\n  return post(\"\".concat(METASTORE_TABLE_URL_PREFIX).concat(getEntryUrlPath(entry), \"partitions\"), {\n    format: 'json',\n    cluster: entry.compute && JSON.stringify(entry.compute) || '\"\"'\n  }, {\n    silenceErrors: silenceErrors,\n    handleSuccess: function handleSuccess(response, resolve, reject) {\n      var adjustedResponse = response || {};\n      adjustedResponse.hueTimestamp = Date.now();\n\n      if (successResponseIsError(response)) {\n        reject(\"Partitions failed: \".concat(extractErrorMessage(response)));\n      } else {\n        resolve(adjustedResponse);\n      }\n    },\n    handleError: function handleError(errorResponse, resolve, reject) {\n      if (errorResponse.response && errorResponse.response.data && errorResponse.response.data.indexOf('is not partitioned') !== -1) {\n        resolve({\n          hueTimestamp: Date.now(),\n          partition_keys_json: [],\n          partition_values_json: []\n        });\n      } else {\n        reject(errorResponse);\n      }\n    }\n  });\n};\n\n/**\n * Checks the status for the given snippet ID\n * Note: similar to notebook and search check_status.\n *\n * @param {Object} options\n * @param {Object} options.notebookJson\n * @param {Object} options.snippetJson\n * @param {boolean} [options.silenceErrors]\n *\n * @return {CancellableJqPromise}\n */\nvar whenAvailable = function whenAvailable(options) {\n  return new CancellablePromise( /*#__PURE__*/function () {\n    var _ref9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(resolve, reject, onCancel) {\n      var promiseToCancel, cancelled, checkStatusPromise, response, status, whenPromise;\n      return regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              cancelled = false;\n              onCancel(function () {\n                cancelled = true;\n\n                if (promiseToCancel) {\n                  promiseToCancel.cancel();\n                }\n              });\n              checkStatusPromise = post(CHECK_STATUS_URL, {\n                notebook: options.notebookJson,\n                snippet: options.snippetJson,\n                cluster: options.entry.compute && JSON.stringify(options.entry.compute) || '\"\"'\n              }, {\n                silenceErrors: options.silenceErrors\n              });\n              _context4.prev = 3;\n              promiseToCancel = checkStatusPromise;\n              _context4.next = 7;\n              return checkStatusPromise;\n\n            case 7:\n              response = _context4.sent;\n\n              if (!(response && response.query_status && response.query_status.status)) {\n                _context4.next = 34;\n                break;\n              }\n\n              status = response.query_status.status;\n\n              if (!(status === 'available')) {\n                _context4.next = 14;\n                break;\n              }\n\n              resolve(response.query_status);\n              _context4.next = 31;\n              break;\n\n            case 14:\n              if (!(status === 'running' || status === 'starting' || status === 'waiting')) {\n                _context4.next = 31;\n                break;\n              }\n\n              _context4.next = 17;\n              return sleep(500);\n\n            case 17:\n              _context4.prev = 17;\n\n              if (cancelled) {\n                _context4.next = 27;\n                break;\n              }\n\n              whenPromise = whenAvailable(options);\n              promiseToCancel = whenPromise;\n              _context4.t0 = resolve;\n              _context4.next = 24;\n              return whenPromise;\n\n            case 24:\n              _context4.t1 = _context4.sent;\n              (0, _context4.t0)(_context4.t1);\n              return _context4.abrupt(\"return\");\n\n            case 27:\n              _context4.next = 31;\n              break;\n\n            case 29:\n              _context4.prev = 29;\n              _context4.t2 = _context4[\"catch\"](17);\n\n            case 31:\n              reject(response.query_status);\n              _context4.next = 35;\n              break;\n\n            case 34:\n              reject('Cancelled');\n\n            case 35:\n              _context4.next = 40;\n              break;\n\n            case 37:\n              _context4.prev = 37;\n              _context4.t3 = _context4[\"catch\"](3);\n              reject(_context4.t3);\n\n            case 40:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4, null, [[3, 37], [17, 29]]);\n    }));\n\n    return function (_x9, _x10, _x11) {\n      return _ref9.apply(this, arguments);\n    };\n  }());\n};\n\nexport var fetchSample = function fetchSample(_ref10) {\n  var entry = _ref10.entry,\n      silenceErrors = _ref10.silenceErrors,\n      operation = _ref10.operation,\n      sampleCount = _ref10.sampleCount;\n  return new CancellablePromise( /*#__PURE__*/function () {\n    var _ref11 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(resolve, reject, onCancel) {\n      var cancellablePromises, notebookJson, snippetJson, cancelQuery, samplePromise, sampleResponse, queryResult, statusPromise, resultStatus, transformResponse, resultPromise, _sampleResponse, sample, closeSessions;\n\n      return regeneratorRuntime.wrap(function _callee7$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              cancellablePromises = [];\n              notebookJson = undefined;\n              snippetJson = undefined;\n\n              cancelQuery = /*#__PURE__*/function () {\n                var _ref12 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {\n                  return regeneratorRuntime.wrap(function _callee5$(_context5) {\n                    while (1) {\n                      switch (_context5.prev = _context5.next) {\n                        case 0:\n                          if (!notebookJson) {\n                            _context5.next = 8;\n                            break;\n                          }\n\n                          _context5.prev = 1;\n                          _context5.next = 4;\n                          return post(CANCEL_STATEMENT_URL, {\n                            notebook: notebookJson,\n                            snippet: snippetJson,\n                            cluster: entry.compute && JSON.stringify(entry.compute) || '\"\"'\n                          }, {\n                            silenceErrors: true\n                          });\n\n                        case 4:\n                          _context5.next = 8;\n                          break;\n\n                        case 6:\n                          _context5.prev = 6;\n                          _context5.t0 = _context5[\"catch\"](1);\n\n                        case 8:\n                        case \"end\":\n                          return _context5.stop();\n                      }\n                    }\n                  }, _callee5, null, [[1, 6]]);\n                }));\n\n                return function cancelQuery() {\n                  return _ref12.apply(this, arguments);\n                };\n              }();\n\n              onCancel(function () {\n                cancellablePromises.forEach(function (cancellable) {\n                  return cancellable.cancel();\n                });\n              });\n              cancellablePromises.push({\n                cancel: function () {\n                  var _cancel = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {\n                    return regeneratorRuntime.wrap(function _callee6$(_context6) {\n                      while (1) {\n                        switch (_context6.prev = _context6.next) {\n                          case 0:\n                            _context6.prev = 0;\n                            _context6.next = 3;\n                            return cancelQuery();\n\n                          case 3:\n                            _context6.next = 7;\n                            break;\n\n                          case 5:\n                            _context6.prev = 5;\n                            _context6.t0 = _context6[\"catch\"](0);\n\n                          case 7:\n                          case \"end\":\n                            return _context6.stop();\n                        }\n                      }\n                    }, _callee6, null, [[0, 5]]);\n                  }));\n\n                  function cancel() {\n                    return _cancel.apply(this, arguments);\n                  }\n\n                  return cancel;\n                }()\n              });\n              samplePromise = post(\"\".concat(SAMPLE_URL_PREFIX).concat(getEntryUrlPath(entry)), {\n                notebook: {},\n                snippet: JSON.stringify({\n                  type: entry.getConnector().id,\n                  compute: entry.compute\n                }),\n                async: true,\n                operation: \"\\\"\".concat(operation || 'default', \"\\\"\"),\n                cluster: entry.compute && JSON.stringify(entry.compute) || '\"\"'\n              }, {\n                silenceErrors: silenceErrors\n              });\n              _context7.prev = 7;\n              cancellablePromises.push(samplePromise);\n              _context7.next = 11;\n              return samplePromise;\n\n            case 11:\n              sampleResponse = _context7.sent;\n              cancellablePromises.pop();\n              queryResult = {\n                id: UUID(),\n                type: sampleResponse.result && sampleResponse.result.type || entry.getConnector().id,\n                compute: entry.compute,\n                status: 'running',\n                result: sampleResponse.result || {}\n              };\n              queryResult.result.type = 'table';\n              notebookJson = JSON.stringify({\n                type: entry.getConnector().id\n              });\n              snippetJson = JSON.stringify(queryResult);\n\n              if (!(sampleResponse && sampleResponse.rows)) {\n                _context7.next = 21;\n                break;\n              }\n\n              // Sync results\n              resolve({\n                type: 'table',\n                hueTimestamp: Date.now(),\n                data: sampleResponse.rows,\n                meta: sampleResponse.full_headers || []\n              });\n              _context7.next = 48;\n              break;\n\n            case 21:\n              statusPromise = whenAvailable({\n                notebookJson: notebookJson,\n                snippetJson: snippetJson,\n                entry: entry,\n                silenceErrors: silenceErrors\n              });\n              cancellablePromises.push(statusPromise);\n              _context7.next = 25;\n              return statusPromise;\n\n            case 25:\n              resultStatus = _context7.sent;\n              cancellablePromises.pop();\n\n              if (!(resultStatus.status !== 'available')) {\n                _context7.next = 30;\n                break;\n              }\n\n              reject();\n              return _context7.abrupt(\"return\");\n\n            case 30:\n              snippetJson = JSON.stringify(queryResult); // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n              // @ts-ignore\n\n              transformResponse = function transformResponse(response) {\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                return JSON.bigdataParse(response);\n              };\n\n              resultPromise = post(FETCH_RESULT_DATA_URL, {\n                notebook: notebookJson,\n                snippet: snippetJson,\n                rows: sampleCount || 100,\n                startOver: 'false'\n              }, {\n                silenceErrors: silenceErrors,\n                transformResponse: transformResponse\n              });\n              _context7.next = 35;\n              return resultPromise;\n\n            case 35:\n              _sampleResponse = _context7.sent;\n              sample = {\n                hueTimestamp: Date.now(),\n                type: 'table',\n                data: _sampleResponse.result && _sampleResponse.result.data || [],\n                meta: _sampleResponse.result && _sampleResponse.result.meta || []\n              };\n              resolve(sample);\n              cancellablePromises.pop();\n              closeSessions = window.CLOSE_SESSIONS;\n\n              if (!(closeSessions && closeSessions[entry.getConnector().dialect || ''] && queryResult.result.handle && queryResult.result.handle.session_id)) {\n                _context7.next = 48;\n                break;\n              }\n\n              _context7.prev = 41;\n              _context7.next = 44;\n              return closeSession({\n                session: {\n                  id: queryResult.result.handle.session_id,\n                  session_id: queryResult.result.handle.session_guid || '',\n                  type: entry.getConnector().id,\n                  properties: []\n                },\n                silenceErrors: silenceErrors\n              });\n\n            case 44:\n              _context7.next = 48;\n              break;\n\n            case 46:\n              _context7.prev = 46;\n              _context7.t0 = _context7[\"catch\"](41);\n\n            case 48:\n              _context7.next = 53;\n              break;\n\n            case 50:\n              _context7.prev = 50;\n              _context7.t1 = _context7[\"catch\"](7);\n              reject();\n\n            case 53:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, _callee7, null, [[7, 50], [41, 46]]);\n    }));\n\n    return function (_x12, _x13, _x14) {\n      return _ref11.apply(this, arguments);\n    };\n  }());\n};\nexport var fetchSourceMetadata = function fetchSourceMetadata(_ref13) {\n  var entry = _ref13.entry,\n      silenceErrors = _ref13.silenceErrors;\n  return post(\"\".concat(AUTOCOMPLETE_URL_PREFIX).concat(getEntryUrlPath(entry)), {\n    notebook: {},\n    snippet: JSON.stringify({\n      type: entry.getConnector().id,\n      source: 'data'\n    }),\n    operation: entry.isModel() ? 'model' : 'default',\n    cluster: entry.compute && JSON.stringify(entry.compute) || '\"\"'\n  }, {\n    silenceErrors: silenceErrors,\n    handleSuccess: function handleSuccess(response, resolve, reject) {\n      var message = response.error || response.message || '';\n      var adjustedResponse = response || {};\n      adjustedResponse.notFound = !!response && response.status === 0 && response.code === 500 && (message.indexOf('Error 10001') !== -1 || message.indexOf('AnalysisException') !== -1);\n      adjustedResponse.hueTimestamp = Date.now();\n\n      if (!adjustedResponse.notFound && successResponseIsError(response)) {\n        reject(extractErrorMessage(response));\n      } else {\n        resolve(adjustedResponse);\n      }\n    }\n  });\n};\nexport var searchEntities = function searchEntities(_ref14) {\n  var limit = _ref14.limit,\n      query = _ref14.query,\n      rawQuery = _ref14.rawQuery,\n      silenceErrors = _ref14.silenceErrors,\n      sources = _ref14.sources;\n  return post(SEARCH_URL, {\n    query_s: JSON.stringify(query),\n    limit: limit || 100,\n    raw_query: !!rawQuery,\n    sources: sources && JSON.stringify(sources) || '[\"sql\"]'\n  }, {\n    silenceErrors: silenceErrors\n  });\n};\nexport var updateNavigatorProperties = function updateNavigatorProperties(_ref15) {\n  var deletedCustomMetadataKeys = _ref15.deletedCustomMetadataKeys,\n      identity = _ref15.identity,\n      modifiedCustomMetadata = _ref15.modifiedCustomMetadata,\n      properties = _ref15.properties,\n      silenceErrors = _ref15.silenceErrors;\n  var data = {\n    id: JSON.stringify(identity)\n  };\n\n  if (properties) {\n    data.properties = JSON.stringify(properties);\n  }\n\n  if (modifiedCustomMetadata) {\n    data.modifiedCustomMetadata = JSON.stringify(modifiedCustomMetadata);\n  }\n\n  if (deletedCustomMetadataKeys) {\n    data.deletedCustomMetadataKeys = JSON.stringify(deletedCustomMetadataKeys);\n  }\n\n  return post(UPDATE_PROPERTIES_URL, data, {\n    silenceErrors: silenceErrors\n  });\n};\nexport var updateSourceMetadata = function updateSourceMetadata(_ref16) {\n  var entry = _ref16.entry,\n      properties = _ref16.properties,\n      silenceErrors = _ref16.silenceErrors;\n  var url;\n  var data = {\n    source_type: entry.getConnector().id\n  };\n\n  if (entry.path.length === 1) {\n    url = \"/metastore/databases/\".concat(entry.path[0], \"/alter\");\n    data.properties = JSON.stringify(properties);\n  } else if (entry.path.length === 2) {\n    url = \"/metastore/table/\".concat(entry.path[0], \"/\").concat(entry.path[1], \"/alter\");\n\n    if (properties !== null && properties !== void 0 && properties.name) {\n      data.new_table_name = properties.name;\n    }\n  } else if (entry.path.length > 2) {\n    url = \"/metastore/table/\".concat(entry.path[0], \"/\").concat(entry.path[1], \"/alter_column\");\n    data.column = entry.path.slice(2).join('.');\n\n    if (properties !== null && properties !== void 0 && properties.name) {\n      data.new_column_name = properties.name;\n    }\n\n    if (properties !== null && properties !== void 0 && properties.type) {\n      data.new_column_type = properties.type;\n    }\n\n    if (properties !== null && properties !== void 0 && properties.partitions) {\n      data.partition_spec = JSON.stringify(properties.partitions);\n    }\n  }\n\n  if (properties !== null && properties !== void 0 && properties.comment) {\n    data.comment = properties.comment;\n  }\n\n  if (!url) {\n    return CancellablePromise.reject();\n  }\n\n  return post(url, data, {\n    silenceErrors: silenceErrors\n  });\n};\nexport var addNavTags = function addNavTags(entityId, tags) {\n  return post(ADD_TAGS_URL, {\n    id: JSON.stringify(entityId),\n    tags: JSON.stringify(tags)\n  });\n};\nexport var deleteNavTags = function deleteNavTags(entityId, tags) {\n  return post(DELETE_TAGS_URL, {\n    id: JSON.stringify(entityId),\n    tags: JSON.stringify(tags)\n  });\n};","// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * Helper function that adds sets the silence errors option to true if not specified\n */\nexport var forceSilencedErrors = function forceSilencedErrors(options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (typeof options.silenceErrors === 'undefined') {\n    options.silenceErrors = true;\n  }\n\n  return options;\n};\n/**\n * Helper function to apply the cancellable option to an existing or new promise\n */\n\nexport var applyCancellable = function applyCancellable(promise, options) {\n  if (promise && promise.preventCancel && (!options || !options.cancellable)) {\n    promise.preventCancel();\n  }\n\n  return promise;\n};","function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport localforage from 'localforage';\nimport { fetchClusters, fetchComputes, fetchNamespaces } from \"./api\";\nimport huePubSub from 'utils/huePubSub';\nimport noop from 'utils/timing/noop';\nimport { CONTEXT_CATALOG_REFRESHED_TOPIC, NAMESPACES_REFRESHED_TOPIC, REFRESH_CONTEXT_CATALOG_TOPIC } from \"./events\";\nvar ContextTypes;\n\n(function (ContextTypes) {\n  ContextTypes[\"Namespace\"] = \"namespace\";\n  ContextTypes[\"Compute\"] = \"compute\";\n  ContextTypes[\"Cluster\"] = \"cluster\";\n})(ContextTypes || (ContextTypes = {}));\n\nvar STORAGE_POSTFIX = window.LOGGED_USERNAME;\nvar CONTEXT_CATALOG_VERSION = 4;\nvar DISABLE_CACHE = true;\nvar store = localforage.createInstance({\n  name: \"HueContextCatalog_\".concat(STORAGE_POSTFIX)\n});\nvar namespacePromises = new Map();\nvar computePromises = new Map();\nvar clusterPromises = new Map();\nhuePubSub.subscribe(REFRESH_CONTEXT_CATALOG_TOPIC, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n  var namespacesToRefresh;\n  return regeneratorRuntime.wrap(function _callee$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          namespacesToRefresh = _toConsumableArray(namespacePromises.keys());\n          namespacePromises.clear();\n          computePromises.clear();\n          clusterPromises.clear();\n          _context.prev = 4;\n          _context.next = 7;\n          return store.clear();\n\n        case 7:\n          _context.next = 11;\n          break;\n\n        case 9:\n          _context.prev = 9;\n          _context.t0 = _context[\"catch\"](4);\n\n        case 11:\n          huePubSub.publish(CONTEXT_CATALOG_REFRESHED_TOPIC);\n          namespacesToRefresh.forEach(function (connectorId) {\n            huePubSub.publish(NAMESPACES_REFRESHED_TOPIC, connectorId);\n          });\n\n        case 13:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _callee, null, [[4, 9]]);\n})));\n\nvar saveLaterToCache = function saveLaterToCache(type, connector, entry) {\n  if (entry) {\n    window.setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n      return regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.prev = 0;\n              _context2.next = 3;\n              return store.setItem(\"\".concat(type, \"_\").concat(connector.id), {\n                version: CONTEXT_CATALOG_VERSION,\n                entry: entry\n              });\n\n            case 3:\n              _context2.next = 7;\n              break;\n\n            case 5:\n              _context2.prev = 5;\n              _context2.t0 = _context2[\"catch\"](0);\n\n            case 7:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[0, 5]]);\n    })), 1000);\n  }\n};\n\nvar deleteFromCache = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(type, connector) {\n    return regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return store.removeItem(\"\".concat(type, \"_\").concat(connector.id));\n\n          case 2:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function deleteFromCache(_x, _x2) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nvar getCached = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(type, connector) {\n    var storedItem;\n    return regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            if (DISABLE_CACHE) {\n              _context4.next = 12;\n              break;\n            }\n\n            _context4.prev = 1;\n            _context4.next = 4;\n            return store.getItem(\"\".concat(type, \"_\").concat(connector.id));\n\n          case 4:\n            storedItem = _context4.sent;\n\n            if (!(storedItem && storedItem.version === CONTEXT_CATALOG_VERSION)) {\n              _context4.next = 7;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", storedItem.entry);\n\n          case 7:\n            _context4.next = 12;\n            break;\n\n          case 9:\n            _context4.prev = 9;\n            _context4.t0 = _context4[\"catch\"](1);\n            console.warn(_context4.t0);\n\n          case 12:\n            return _context4.abrupt(\"return\", undefined);\n\n          case 13:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4, null, [[1, 9]]);\n  }));\n\n  return function getCached(_x3, _x4) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nexport var getNamespaces = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(_ref5) {\n    var connector, clearCache, silenceErrors, notifyForRefresh;\n    return regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            connector = _ref5.connector, clearCache = _ref5.clearCache, silenceErrors = _ref5.silenceErrors;\n            notifyForRefresh = namespacePromises.has(connector.id) && clearCache;\n\n            if (!clearCache) {\n              _context6.next = 6;\n              break;\n            }\n\n            namespacePromises[\"delete\"](connector.id);\n            _context6.next = 6;\n            return deleteFromCache(ContextTypes.Namespace, connector);\n\n          case 6:\n            if (!namespacePromises.has(connector.id)) {\n              namespacePromises.set(connector.id, new Promise( /*#__PURE__*/function () {\n                var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(resolve, reject) {\n                  var cached, fetchedNamespaces, namespaces, dynamic, connectorNamespaces;\n                  return regeneratorRuntime.wrap(function _callee5$(_context5) {\n                    while (1) {\n                      switch (_context5.prev = _context5.next) {\n                        case 0:\n                          _context5.prev = 0;\n                          _context5.next = 3;\n                          return getCached(ContextTypes.Namespace, connector);\n\n                        case 3:\n                          cached = _context5.sent;\n\n                          if (!cached) {\n                            _context5.next = 7;\n                            break;\n                          }\n\n                          resolve(cached);\n                          return _context5.abrupt(\"return\");\n\n                        case 7:\n                          _context5.next = 11;\n                          break;\n\n                        case 9:\n                          _context5.prev = 9;\n                          _context5.t0 = _context5[\"catch\"](0);\n\n                        case 11:\n                          _context5.next = 13;\n                          return fetchNamespaces(connector, silenceErrors);\n\n                        case 13:\n                          fetchedNamespaces = _context5.sent;\n                          namespaces = fetchedNamespaces[connector.id];\n\n                          if (namespaces) {\n                            dynamic = fetchedNamespaces.dynamicClusters;\n                            namespaces.forEach(function (namespace) {\n                              // Adapt computes, TODO: Still needed?\n                              namespace.computes.forEach(function (compute) {\n                                if (!compute.id && compute.crn) {\n                                  compute.id = compute.crn;\n                                }\n\n                                if (!compute.name && compute.clusterName) {\n                                  compute.name = compute.clusterName;\n                                }\n                              });\n                            });\n                            connectorNamespaces = {\n                              namespaces: namespaces.filter(function (namespace) {\n                                return namespace.name;\n                              }),\n                              dynamic: dynamic,\n                              hueTimestamp: Date.now()\n                            };\n                            resolve(connectorNamespaces);\n\n                            if (notifyForRefresh) {\n                              huePubSub.publish(NAMESPACES_REFRESHED_TOPIC, connector.id);\n                            }\n\n                            if (connectorNamespaces.namespaces.length) {\n                              saveLaterToCache(ContextTypes.Namespace, connector, connectorNamespaces);\n                            } else {\n                              deleteFromCache(ContextTypes.Namespace, connector)[\"catch\"](noop);\n                            }\n                          } else {\n                            reject();\n                          }\n\n                        case 16:\n                        case \"end\":\n                          return _context5.stop();\n                      }\n                    }\n                  }, _callee5, null, [[0, 9]]);\n                }));\n\n                return function (_x6, _x7) {\n                  return _ref7.apply(this, arguments);\n                };\n              }()));\n            }\n\n            return _context6.abrupt(\"return\", namespacePromises.get(connector.id));\n\n          case 8:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n\n  return function getNamespaces(_x5) {\n    return _ref6.apply(this, arguments);\n  };\n}();\nexport var getComputes = /*#__PURE__*/function () {\n  var _ref9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(_ref8) {\n    var connector, clearCache, silenceErrors;\n    return regeneratorRuntime.wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            connector = _ref8.connector, clearCache = _ref8.clearCache, silenceErrors = _ref8.silenceErrors;\n\n            if (!clearCache) {\n              _context8.next = 5;\n              break;\n            }\n\n            computePromises[\"delete\"](connector.id);\n            _context8.next = 5;\n            return deleteFromCache(ContextTypes.Compute, connector);\n\n          case 5:\n            if (!computePromises.has(connector.id)) {\n              computePromises.set(connector.id, new Promise( /*#__PURE__*/function () {\n                var _ref10 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(resolve, reject) {\n                  var cached, fetchedComputes, computes;\n                  return regeneratorRuntime.wrap(function _callee7$(_context7) {\n                    while (1) {\n                      switch (_context7.prev = _context7.next) {\n                        case 0:\n                          _context7.prev = 0;\n                          _context7.next = 3;\n                          return getCached(ContextTypes.Compute, connector);\n\n                        case 3:\n                          cached = _context7.sent;\n\n                          if (!cached) {\n                            _context7.next = 7;\n                            break;\n                          }\n\n                          resolve(cached);\n                          return _context7.abrupt(\"return\");\n\n                        case 7:\n                          _context7.next = 11;\n                          break;\n\n                        case 9:\n                          _context7.prev = 9;\n                          _context7.t0 = _context7[\"catch\"](0);\n\n                        case 11:\n                          _context7.next = 13;\n                          return fetchComputes(connector, silenceErrors);\n\n                        case 13:\n                          fetchedComputes = _context7.sent;\n                          computes = fetchedComputes[connector.id];\n\n                          if (computes) {\n                            resolve(computes);\n\n                            if (computes.length) {\n                              saveLaterToCache(ContextTypes.Compute, connector, computes);\n                            } else {\n                              deleteFromCache(ContextTypes.Compute, connector)[\"catch\"](noop);\n                            }\n                          } else {\n                            reject();\n                          }\n\n                        case 16:\n                        case \"end\":\n                          return _context7.stop();\n                      }\n                    }\n                  }, _callee7, null, [[0, 9]]);\n                }));\n\n                return function (_x9, _x10) {\n                  return _ref10.apply(this, arguments);\n                };\n              }()));\n            }\n\n            return _context8.abrupt(\"return\", computePromises.get(connector.id));\n\n          case 7:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n\n  return function getComputes(_x8) {\n    return _ref9.apply(this, arguments);\n  };\n}();\nexport var getClusters = /*#__PURE__*/function () {\n  var _ref12 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(_ref11) {\n    var connector, clearCache, silenceErrors;\n    return regeneratorRuntime.wrap(function _callee10$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            connector = _ref11.connector, clearCache = _ref11.clearCache, silenceErrors = _ref11.silenceErrors;\n\n            if (!clearCache) {\n              _context10.next = 5;\n              break;\n            }\n\n            clusterPromises[\"delete\"](connector.id);\n            _context10.next = 5;\n            return deleteFromCache(ContextTypes.Cluster, connector);\n\n          case 5:\n            if (!clusterPromises.has(connector.id)) {\n              clusterPromises.set(connector.id, new Promise( /*#__PURE__*/function () {\n                var _ref13 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(resolve, reject) {\n                  var cached, fetchedClusters, clusters;\n                  return regeneratorRuntime.wrap(function _callee9$(_context9) {\n                    while (1) {\n                      switch (_context9.prev = _context9.next) {\n                        case 0:\n                          _context9.prev = 0;\n                          _context9.next = 3;\n                          return getCached(ContextTypes.Cluster, connector);\n\n                        case 3:\n                          cached = _context9.sent;\n\n                          if (!cached) {\n                            _context9.next = 7;\n                            break;\n                          }\n\n                          resolve(cached);\n                          return _context9.abrupt(\"return\");\n\n                        case 7:\n                          _context9.next = 11;\n                          break;\n\n                        case 9:\n                          _context9.prev = 9;\n                          _context9.t0 = _context9[\"catch\"](0);\n\n                        case 11:\n                          _context9.next = 13;\n                          return fetchClusters(connector, silenceErrors);\n\n                        case 13:\n                          fetchedClusters = _context9.sent;\n                          clusters = fetchedClusters[connector.id];\n\n                          if (clusters) {\n                            resolve(clusters);\n\n                            if (clusters.length) {\n                              saveLaterToCache(ContextTypes.Cluster, connector, clusters);\n                            } else {\n                              deleteFromCache(ContextTypes.Cluster, connector)[\"catch\"](noop);\n                            }\n                          } else {\n                            reject();\n                          }\n\n                        case 16:\n                        case \"end\":\n                          return _context9.stop();\n                      }\n                    }\n                  }, _callee9, null, [[0, 9]]);\n                }));\n\n                return function (_x12, _x13) {\n                  return _ref13.apply(this, arguments);\n                };\n              }()));\n            }\n\n            return _context10.abrupt(\"return\", clusterPromises.get(connector.id));\n\n          case 7:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, _callee10);\n  }));\n\n  return function getClusters(_x11) {\n    return _ref12.apply(this, arguments);\n  };\n}();\nexport default {\n  getNamespaces: getNamespaces,\n  getComputes: getComputes,\n  getClusters: getClusters\n};","function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport localforage from 'localforage';\nimport { CancellablePromise } from 'api/cancellablePromise';\nimport { applyCancellable } from 'catalog/catalogUtils';\nimport DataCatalogEntry from 'catalog/DataCatalogEntry';\nimport GeneralDataCatalog from 'catalog/GeneralDataCatalog';\nimport MultiTableEntry from 'catalog/MultiTableEntry';\nimport { SqlAnalyzerMode } from \"./analyzer/types\";\nvar STORAGE_POSTFIX = window.LOGGED_USERNAME || '';\nvar DATA_CATALOG_VERSION = 5;\nvar _cacheEnabled = true;\n/**\n * Creates a cache identifier given a namespace and path(s)\n */\n\nvar generateEntryCacheId = function generateEntryCacheId(options) {\n  var id = options.namespace.id;\n\n  if (options.path) {\n    if (typeof options.path === 'string') {\n      id += '_' + options.path;\n    } else if (options.path.length) {\n      id += '_' + options.path.join('.');\n    }\n  } else if (options.paths && options.paths.length) {\n    var pathSet = {};\n    options.paths.forEach(function (path) {\n      pathSet[path.join('.')] = true;\n    });\n    var uniquePaths = Object.keys(pathSet);\n    uniquePaths.sort();\n    id += '_' + uniquePaths.join(',');\n  }\n\n  return id;\n};\n\nvar isFresh = function isFresh(storeEntryValue, ttl) {\n  var confTtl = window.CACHEABLE_TTL || {};\n  var ttlToCheck = typeof ttl !== 'undefined' ? ttl : confTtl[\"default\"];\n\n  if (!storeEntryValue.hueTimestamp || typeof ttlToCheck === 'undefined') {\n    return true;\n  }\n\n  return Date.now() - storeEntryValue.hueTimestamp < ttlToCheck;\n};\n/**\n * Helper function to fill a catalog entry with cached metadata.\n */\n\n\nvar mergeEntry = function mergeEntry(dataCatalogEntry, storeEntry) {\n  if (storeEntry.version !== DATA_CATALOG_VERSION) {\n    return;\n  }\n\n  if (storeEntry.definition && isFresh(storeEntry.definition)) {\n    dataCatalogEntry.definition = storeEntry.definition;\n  }\n\n  if (storeEntry.sourceMeta && isFresh(storeEntry.sourceMeta)) {\n    dataCatalogEntry.sourceMeta = storeEntry.sourceMeta;\n    dataCatalogEntry.sourceMetaPromise = CancellablePromise.resolve(dataCatalogEntry.sourceMeta);\n  }\n\n  if (storeEntry.analysis && isFresh(storeEntry.analysis)) {\n    dataCatalogEntry.analysis = storeEntry.analysis;\n    dataCatalogEntry.analysisPromise = CancellablePromise.resolve(dataCatalogEntry.analysis);\n  }\n\n  if (storeEntry.partitions && isFresh(storeEntry.partitions)) {\n    dataCatalogEntry.partitions = storeEntry.partitions;\n    dataCatalogEntry.partitionsPromise = CancellablePromise.resolve(dataCatalogEntry.partitions);\n  }\n\n  if (storeEntry.sample && isFresh(storeEntry.sample)) {\n    dataCatalogEntry.sample = storeEntry.sample;\n    dataCatalogEntry.samplePromise = CancellablePromise.resolve(dataCatalogEntry.sample);\n  }\n\n  if (storeEntry.navigatorMeta && isFresh(storeEntry.navigatorMeta)) {\n    dataCatalogEntry.navigatorMeta = storeEntry.navigatorMeta;\n    dataCatalogEntry.navigatorMetaPromise = CancellablePromise.resolve(dataCatalogEntry.navigatorMeta);\n  }\n\n  if (dataCatalogEntry.getConnector().optimizer !== SqlAnalyzerMode.local) {\n    var confTtl = window.CACHEABLE_TTL || {};\n\n    if (storeEntry.sqlAnalyzerMeta && isFresh(storeEntry.sqlAnalyzerMeta, confTtl.sqlAnalyzer)) {\n      dataCatalogEntry.sqlAnalyzerMeta = storeEntry.sqlAnalyzerMeta;\n      dataCatalogEntry.sqlAnalyzerMetaPromise = CancellablePromise.resolve(dataCatalogEntry.sqlAnalyzerMeta);\n    }\n\n    if (storeEntry.sqlAnalyzerPopularity && isFresh(storeEntry.sqlAnalyzerPopularity, confTtl.sqlAnalyzer)) {\n      dataCatalogEntry.sqlAnalyzerPopularity = storeEntry.sqlAnalyzerPopularity;\n    }\n  }\n};\n/**\n * Helper function to fill a multi table catalog entry with cached metadata.\n */\n\n\nvar mergeMultiTableEntry = function mergeMultiTableEntry(multiTableEntry, storeEntry) {\n  if (multiTableEntry.getConnector().optimizer === SqlAnalyzerMode.local || storeEntry.version !== DATA_CATALOG_VERSION) {\n    return;\n  }\n\n  var confTtl = window.CACHEABLE_TTL || {};\n\n  if (storeEntry.topAggs && isFresh(storeEntry.topAggs, confTtl.sqlAnalyzer)) {\n    multiTableEntry.topAggs = storeEntry.topAggs;\n    multiTableEntry.topAggsPromise = CancellablePromise.resolve(multiTableEntry.topAggs);\n  }\n\n  if (storeEntry.topColumns && isFresh(storeEntry.topColumns, confTtl.sqlAnalyzer)) {\n    multiTableEntry.topColumns = storeEntry.topColumns;\n    multiTableEntry.topColumnsPromise = CancellablePromise.resolve(multiTableEntry.topColumns);\n  }\n\n  if (storeEntry.topFilters && isFresh(storeEntry.topFilters, confTtl.sqlAnalyzer)) {\n    multiTableEntry.topFilters = storeEntry.topFilters;\n    multiTableEntry.topFiltersPromise = CancellablePromise.resolve(multiTableEntry.topFilters);\n  }\n\n  if (storeEntry.topJoins && isFresh(storeEntry.topJoins, confTtl.sqlAnalyzer)) {\n    multiTableEntry.topJoins = storeEntry.topJoins;\n    multiTableEntry.topJoinsPromise = CancellablePromise.resolve(multiTableEntry.topJoins);\n  }\n};\n\nexport var DataCatalog = /*#__PURE__*/function () {\n  function DataCatalog(connector) {\n    _classCallCheck(this, DataCatalog);\n\n    this.connector = void 0;\n    this.entries = {};\n    this.temporaryEntries = {};\n    this.multiTableEntries = {};\n    this.store = void 0;\n    this.multiTableStore = void 0;\n    this.invalidatePromise = void 0;\n\n    if (!connector || !connector.id) {\n      throw new Error('DataCatalog created without connector or id');\n    }\n\n    this.connector = connector;\n    this.store = localforage.createInstance({\n      name: 'HueDataCatalog_' + this.connector.id + '_' + STORAGE_POSTFIX\n    });\n    this.multiTableStore = localforage.createInstance({\n      name: 'HueDataCatalog_' + this.connector.id + '_multiTable_' + STORAGE_POSTFIX\n    });\n  }\n  /**\n   * Disables the caching for subsequent operations, mainly used for test purposes\n   */\n\n\n  _createClass(DataCatalog, [{\n    key: \"canHaveSqlAnalyzerMeta\",\n    value:\n    /**\n     * Returns true if the catalog can have SQL Analyzer metadata\n     */\n    function canHaveSqlAnalyzerMeta() {\n      return !!(window.HAS_SQL_ANALYZER && this.connector && this.connector.optimizer && this.connector.optimizer !== SqlAnalyzerMode.off);\n    }\n    /**\n     * Clears the data catalog and cache for the given path and any children thereof.\n     */\n\n  }, {\n    key: \"clearStorageCascade\",\n    value: function () {\n      var _clearStorageCascade = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(namespace, compute, pathToClear) {\n        var _this = this;\n\n        var keyPrefix, deletePromises, keys;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(!namespace || !compute)) {\n                  _context.next = 5;\n                  break;\n                }\n\n                if (!(!pathToClear || pathToClear.length === 0)) {\n                  _context.next = 4;\n                  break;\n                }\n\n                this.entries = {};\n                return _context.abrupt(\"return\", this.store.clear());\n\n              case 4:\n                return _context.abrupt(\"return\");\n\n              case 5:\n                keyPrefix = generateEntryCacheId({\n                  namespace: namespace,\n                  path: pathToClear\n                });\n                Object.keys(this.entries).forEach(function (key) {\n                  if (key.indexOf(keyPrefix) === 0) {\n                    delete _this.entries[key];\n                  }\n                });\n                deletePromises = [];\n                _context.prev = 8;\n                _context.next = 11;\n                return this.store.keys();\n\n              case 11:\n                keys = _context.sent;\n                keys.forEach(function (key) {\n                  if (key.indexOf(keyPrefix) === 0) {\n                    deletePromises.push(_this.store.removeItem(key));\n                  }\n                });\n                _context.next = 15;\n                return Promise.all(deletePromises);\n\n              case 15:\n                _context.next = 19;\n                break;\n\n              case 17:\n                _context.prev = 17;\n                _context.t0 = _context[\"catch\"](8);\n\n              case 19:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[8, 17]]);\n      }));\n\n      function clearStorageCascade(_x, _x2, _x3) {\n        return _clearStorageCascade.apply(this, arguments);\n      }\n\n      return clearStorageCascade;\n    }()\n    /**\n     * Updates the cache for the given entry\n     */\n\n  }, {\n    key: \"persistCatalogEntry\",\n    value: function () {\n      var _persistCatalogEntry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(dataCatalogEntry) {\n        var confTtl, identifier;\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                confTtl = window.CACHEABLE_TTL || {};\n\n                if (!(!_cacheEnabled || !confTtl[\"default\"] || confTtl[\"default\"] <= 0)) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 3:\n                identifier = generateEntryCacheId(dataCatalogEntry);\n                _context2.next = 6;\n                return this.store.setItem(identifier, {\n                  version: DATA_CATALOG_VERSION,\n                  definition: dataCatalogEntry.definition,\n                  sourceMeta: dataCatalogEntry.sourceMeta,\n                  analysis: dataCatalogEntry.analysis,\n                  partitions: dataCatalogEntry.partitions,\n                  sample: dataCatalogEntry.sample,\n                  navigatorMeta: dataCatalogEntry.navigatorMeta,\n                  sqlAnalyzerMeta: this.connector.optimizer !== SqlAnalyzerMode.local ? dataCatalogEntry.sqlAnalyzerMeta : undefined,\n                  sqlAnalyzerPopularity: this.connector.optimizer !== SqlAnalyzerMode.local ? dataCatalogEntry.sqlAnalyzerPopularity : undefined\n                });\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function persistCatalogEntry(_x4) {\n        return _persistCatalogEntry.apply(this, arguments);\n      }\n\n      return persistCatalogEntry;\n    }()\n    /**\n     * Loads SQL Analyzer popularity for multiple tables in one go.\n     */\n\n  }, {\n    key: \"loadSqlAnalyzerPopularityForTables\",\n    value: function loadSqlAnalyzerPopularityForTables(options) {\n      var _this2 = this;\n\n      var cancellablePromises = [];\n      var popularEntries = [];\n      var pathsToLoad = [];\n      var existingPromises = [];\n      options.paths.forEach(function (path) {\n        var existingPromise = new Promise( /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(resolve, reject) {\n            var tableEntry, existingPopularEntries, childPromise, childEntries;\n            return regeneratorRuntime.wrap(function _callee3$(_context3) {\n              while (1) {\n                switch (_context3.prev = _context3.next) {\n                  case 0:\n                    _context3.prev = 0;\n                    _context3.next = 3;\n                    return _this2.getEntry({\n                      namespace: options.namespace,\n                      compute: options.compute,\n                      path: path\n                    });\n\n                  case 3:\n                    tableEntry = _context3.sent;\n\n                    if (!tableEntry.sqlAnalyzerPopularityForChildrenPromise) {\n                      _context3.next = 11;\n                      break;\n                    }\n\n                    _context3.next = 7;\n                    return tableEntry.sqlAnalyzerPopularityForChildrenPromise;\n\n                  case 7:\n                    existingPopularEntries = _context3.sent;\n                    popularEntries.push.apply(popularEntries, _toConsumableArray(existingPopularEntries));\n                    _context3.next = 21;\n                    break;\n\n                  case 11:\n                    if (!(tableEntry.definition && tableEntry.definition.sqlAnalyzerLoaded)) {\n                      _context3.next = 20;\n                      break;\n                    }\n\n                    childPromise = tableEntry.getChildren(_objectSpread(_objectSpread({}, options), {}, {\n                      silenceErrors: true\n                    }));\n                    cancellablePromises.push(childPromise);\n                    _context3.next = 16;\n                    return childPromise;\n\n                  case 16:\n                    childEntries = _context3.sent;\n                    childEntries.forEach(function (childEntry) {\n                      if (childEntry.sqlAnalyzerPopularity) {\n                        popularEntries.push(childEntry);\n                      }\n                    });\n                    _context3.next = 21;\n                    break;\n\n                  case 20:\n                    pathsToLoad.push(path);\n\n                  case 21:\n                    _context3.next = 26;\n                    break;\n\n                  case 23:\n                    _context3.prev = 23;\n                    _context3.t0 = _context3[\"catch\"](0);\n                    reject(_context3.t0);\n\n                  case 26:\n                    resolve();\n\n                  case 27:\n                  case \"end\":\n                    return _context3.stop();\n                }\n              }\n            }, _callee3, null, [[0, 23]]);\n          }));\n\n          return function (_x5, _x6) {\n            return _ref.apply(this, arguments);\n          };\n        }());\n        existingPromises.push(existingPromise);\n      });\n      var popularityPromise = new CancellablePromise( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(resolve, reject, onCancel) {\n          var fetchPromise, data, perTable, splitSqlAnalyzerValuesPerTable, tablePromises;\n          return regeneratorRuntime.wrap(function _callee5$(_context5) {\n            while (1) {\n              switch (_context5.prev = _context5.next) {\n                case 0:\n                  onCancel(function () {\n                    cancellablePromises.forEach(function (cancellable) {\n                      cancellable.cancel();\n                    });\n                  });\n                  _context5.prev = 1;\n                  _context5.next = 4;\n                  return Promise.all(existingPromises);\n\n                case 4:\n                  _context5.next = 8;\n                  break;\n\n                case 6:\n                  _context5.prev = 6;\n                  _context5.t0 = _context5[\"catch\"](1);\n\n                case 8:\n                  if (pathsToLoad.length) {\n                    _context5.next = 11;\n                    break;\n                  }\n\n                  resolve(popularEntries);\n                  return _context5.abrupt(\"return\");\n\n                case 11:\n                  fetchPromise = options.sqlAnalyzer.fetchPopularity({\n                    silenceErrors: true,\n                    paths: pathsToLoad\n                  });\n                  cancellablePromises.push(fetchPromise);\n                  _context5.prev = 13;\n                  _context5.next = 16;\n                  return fetchPromise;\n\n                case 16:\n                  data = _context5.sent;\n                  perTable = {};\n\n                  splitSqlAnalyzerValuesPerTable = function splitSqlAnalyzerValuesPerTable(listName) {\n                    var values = data.values && data.values[listName];\n\n                    if (values) {\n                      values.forEach(function (column) {\n                        var tableMeta = perTable[column.dbName + '.' + column.tableName];\n\n                        if (!tableMeta) {\n                          tableMeta = {\n                            values: {}\n                          };\n                          perTable[column.dbName + '.' + column.tableName] = tableMeta;\n                        }\n\n                        if (tableMeta.values) {\n                          var valuesList = tableMeta.values[listName];\n\n                          if (!valuesList) {\n                            valuesList = [];\n                            tableMeta.values[listName] = valuesList;\n                          }\n\n                          valuesList.push(column);\n                        }\n                      });\n                    }\n                  };\n\n                  if (data.values) {\n                    splitSqlAnalyzerValuesPerTable('filterColumns');\n                    splitSqlAnalyzerValuesPerTable('groupbyColumns');\n                    splitSqlAnalyzerValuesPerTable('joinColumns');\n                    splitSqlAnalyzerValuesPerTable('orderbyColumns');\n                    splitSqlAnalyzerValuesPerTable('selectColumns');\n                  }\n\n                  tablePromises = Object.keys(perTable).map(function (path) {\n                    return new Promise( /*#__PURE__*/function () {\n                      var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(resolve) {\n                        var entry, applyPromise;\n                        return regeneratorRuntime.wrap(function _callee4$(_context4) {\n                          while (1) {\n                            switch (_context4.prev = _context4.next) {\n                              case 0:\n                                _context4.prev = 0;\n                                _context4.next = 3;\n                                return _this2.getEntry({\n                                  namespace: options.namespace,\n                                  compute: options.compute,\n                                  path: path\n                                });\n\n                              case 3:\n                                entry = _context4.sent;\n                                applyPromise = entry.applySqlAnalyzerResponseToChildren(perTable[path], _objectSpread(_objectSpread({}, options), {}, {\n                                  silenceErrors: true\n                                }));\n                                cancellablePromises.push(applyPromise);\n                                _context4.t0 = popularEntries.push;\n                                _context4.t1 = popularEntries;\n                                _context4.t2 = _toConsumableArray;\n                                _context4.next = 11;\n                                return applyPromise;\n\n                              case 11:\n                                _context4.t3 = _context4.sent;\n                                _context4.t4 = (0, _context4.t2)(_context4.t3);\n\n                                _context4.t0.apply.call(_context4.t0, _context4.t1, _context4.t4);\n\n                                _context4.next = 18;\n                                break;\n\n                              case 16:\n                                _context4.prev = 16;\n                                _context4.t5 = _context4[\"catch\"](0);\n\n                              case 18:\n                                resolve();\n\n                              case 19:\n                              case \"end\":\n                                return _context4.stop();\n                            }\n                          }\n                        }, _callee4, null, [[0, 16]]);\n                      }));\n\n                      return function (_x10) {\n                        return _ref3.apply(this, arguments);\n                      };\n                    }());\n                  });\n                  Promise.all(tablePromises)[\"finally\"](function () {\n                    resolve(popularEntries);\n                  });\n                  _context5.next = 27;\n                  break;\n\n                case 24:\n                  _context5.prev = 24;\n                  _context5.t1 = _context5[\"catch\"](13);\n                  resolve(popularEntries);\n\n                case 27:\n                case \"end\":\n                  return _context5.stop();\n              }\n            }\n          }, _callee5, null, [[1, 6], [13, 24]]);\n        }));\n\n        return function (_x7, _x8, _x9) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n      return applyCancellable(popularityPromise);\n    }\n  }, {\n    key: \"getKnownEntry\",\n    value: function () {\n      var _getKnownEntry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(options) {\n        return regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                return _context6.abrupt(\"return\", this.entries[generateEntryCacheId(options)]);\n\n              case 1:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function getKnownEntry(_x11) {\n        return _getKnownEntry.apply(this, arguments);\n      }\n\n      return getKnownEntry;\n    }()\n    /**\n     * Adds a temporary table to the data catalog. This would allow autocomplete etc. of tables that haven't\n     * been created yet.\n     *\n     * Calling this returns a handle that allows deletion of any created entries by calling delete() on the handle.\n     */\n\n  }, {\n    key: \"addTemporaryTable\",\n    value: function addTemporaryTable(options) {\n      var _this3 = this;\n\n      var database = options.database || 'default';\n      var path = [database, options.name];\n      var identifiersToClean = [];\n\n      var addEntryMeta = function addEntryMeta(entry, sourceMeta) {\n        entry.sourceMeta = sourceMeta || entry.definition;\n        entry.sourceMetaPromise = CancellablePromise.resolve(entry.sourceMeta);\n      };\n\n      var sourceIdentifier = generateEntryCacheId({\n        namespace: options.namespace,\n        path: []\n      }); // Create the source entry if not already present\n\n      if (!this.temporaryEntries[sourceIdentifier]) {\n        var sourceEntry = new DataCatalogEntry({\n          isTemporary: true,\n          dataCatalog: this,\n          namespace: options.namespace,\n          compute: options.compute,\n          path: [],\n          definition: {\n            index: 0,\n            sqlAnalyzerLoaded: true,\n            type: 'source'\n          }\n        });\n        addEntryMeta(sourceEntry);\n        identifiersToClean.push(sourceIdentifier);\n        sourceEntry.childrenPromise = CancellablePromise.resolve([]);\n        this.temporaryEntries[sourceIdentifier] = Promise.resolve(sourceEntry);\n      }\n\n      this.temporaryEntries[sourceIdentifier].then( /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(sourceEntry) {\n          var existingTemporaryDatabases, databaseIdentifier, _databaseEntry, databaseEntry, existingTemporaryTables, tableIdentifier, _tableEntry, index, tableEntry, tableSourceMeta, columnEntries;\n\n          return regeneratorRuntime.wrap(function _callee7$(_context7) {\n            while (1) {\n              switch (_context7.prev = _context7.next) {\n                case 0:\n                  _context7.next = 2;\n                  return sourceEntry.getChildren();\n\n                case 2:\n                  existingTemporaryDatabases = _context7.sent;\n                  databaseIdentifier = generateEntryCacheId({\n                    namespace: options.namespace,\n                    path: [database]\n                  }); // Create the database entry if not already present\n\n                  if (!_this3.temporaryEntries[databaseIdentifier]) {\n                    _databaseEntry = new DataCatalogEntry({\n                      isTemporary: true,\n                      dataCatalog: _this3,\n                      namespace: options.namespace,\n                      compute: options.compute,\n                      path: [database],\n                      definition: {\n                        index: 0,\n                        sqlAnalyzerLoaded: true,\n                        type: 'database'\n                      }\n                    });\n                    addEntryMeta(_databaseEntry);\n                    _databaseEntry.childrenPromise = CancellablePromise.resolve([]);\n                    identifiersToClean.push(databaseIdentifier);\n                    existingTemporaryDatabases.push(_databaseEntry);\n                    _this3.temporaryEntries[databaseIdentifier] = Promise.resolve(_databaseEntry);\n                  }\n\n                  _context7.next = 7;\n                  return _this3.temporaryEntries[databaseIdentifier];\n\n                case 7:\n                  databaseEntry = _context7.sent;\n                  _context7.next = 10;\n                  return databaseEntry.getChildren();\n\n                case 10:\n                  existingTemporaryTables = _context7.sent;\n                  tableIdentifier = generateEntryCacheId({\n                    namespace: options.namespace,\n                    path: path\n                  }); // Unlink any existing table with the same identifier\n\n                  if (!_this3.temporaryEntries[tableIdentifier]) {\n                    _context7.next = 18;\n                    break;\n                  }\n\n                  _context7.next = 15;\n                  return _this3.temporaryEntries[tableIdentifier];\n\n                case 15:\n                  _tableEntry = _context7.sent;\n                  index = existingTemporaryTables.indexOf(_tableEntry);\n\n                  if (index !== -1) {\n                    existingTemporaryTables.splice(index, 1);\n                  }\n\n                case 18:\n                  tableEntry = new DataCatalogEntry({\n                    isTemporary: true,\n                    dataCatalog: _this3,\n                    namespace: options.namespace,\n                    compute: options.compute,\n                    path: path,\n                    definition: {\n                      comment: '',\n                      index: existingTemporaryTables.length,\n                      name: options.name,\n                      sqlAnalyzerLoaded: true,\n                      type: 'table'\n                    }\n                  });\n                  existingTemporaryTables.push(tableEntry);\n                  tableSourceMeta = {\n                    columns: (options.columns || []).map(function (col) {\n                      return col.name;\n                    }),\n                    extended_columns: options.columns || [],\n                    comment: '',\n                    notFound: false,\n                    is_view: false\n                  };\n                  addEntryMeta(tableEntry, tableSourceMeta);\n                  tableEntry.sample = {\n                    data: options.sample,\n                    meta: options.columns,\n                    type: 'table'\n                  };\n                  tableEntry.samplePromise = CancellablePromise.resolve(tableEntry.sample);\n                  identifiersToClean.push(tableIdentifier);\n                  _this3.temporaryEntries[tableIdentifier] = Promise.resolve(tableEntry);\n                  columnEntries = [];\n                  tableEntry.childrenPromise = CancellablePromise.resolve(columnEntries);\n                  options.columns.forEach(function (column, index) {\n                    var columnPath = [].concat(path, [column.name]);\n                    var columnEntry = new DataCatalogEntry({\n                      isTemporary: true,\n                      dataCatalog: _this3,\n                      namespace: options.namespace,\n                      compute: options.compute,\n                      path: columnPath,\n                      definition: {\n                        comment: '',\n                        index: index,\n                        name: column.name,\n                        partitionKey: false,\n                        type: column.type\n                      }\n                    });\n                    columnEntry.sample = {\n                      data: options.sample.map(function (sampleRow) {\n                        return [sampleRow[index]];\n                      }),\n                      meta: [column],\n                      type: 'table'\n                    };\n                    columnEntry.samplePromise = CancellablePromise.resolve(columnEntry.sample);\n                    tableSourceMeta.columns.push(column.name);\n                    tableSourceMeta.extended_columns.push(columnEntry.definition);\n                    addEntryMeta(columnEntry, {\n                      comment: '',\n                      name: column.name,\n                      notFound: false,\n                      sample: columnEntry.sample.data,\n                      type: column.type\n                    });\n                    var columnIdentifier = generateEntryCacheId({\n                      namespace: options.namespace,\n                      path: columnPath\n                    });\n                    identifiersToClean.push(columnIdentifier);\n                    _this3.temporaryEntries[columnIdentifier] = CancellablePromise.resolve(columnEntry);\n                  });\n\n                case 29:\n                case \"end\":\n                  return _context7.stop();\n              }\n            }\n          }, _callee7);\n        }));\n\n        return function (_x12) {\n          return _ref4.apply(this, arguments);\n        };\n      }());\n      return {\n        \"delete\": function _delete() {\n          while (identifiersToClean.length) {\n            var nextToDelete = identifiersToClean.pop();\n\n            if (nextToDelete) {\n              delete _this3.temporaryEntries[nextToDelete];\n            }\n          }\n        }\n      };\n    }\n  }, {\n    key: \"getEntry\",\n    value: function () {\n      var _getEntry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(options) {\n        var _this4 = this;\n\n        var identifier;\n        return regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                identifier = generateEntryCacheId(options);\n\n                if (!options.temporaryOnly) {\n                  _context8.next = 3;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", this.temporaryEntries[identifier] || $.Deferred().reject().promise());\n\n              case 3:\n                if (!this.entries[identifier]) {\n                  _context8.next = 5;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", this.entries[identifier]);\n\n              case 5:\n                this.entries[identifier] = new Promise(function (resolve) {\n                  if (!_cacheEnabled) {\n                    resolve(new DataCatalogEntry({\n                      dataCatalog: _this4,\n                      namespace: options.namespace,\n                      compute: options.compute,\n                      path: options.path,\n                      definition: options.definition\n                    }));\n                  } else {\n                    _this4.store.getItem(identifier).then(function (storeEntry) {\n                      var definition = storeEntry ? storeEntry.definition : options.definition;\n                      var entry = new DataCatalogEntry({\n                        dataCatalog: _this4,\n                        namespace: options.namespace,\n                        compute: options.compute,\n                        path: options.path,\n                        definition: definition\n                      });\n\n                      if (storeEntry) {\n                        mergeEntry(entry, storeEntry);\n                      } else if (!options.cachedOnly && options.definition) {\n                        entry.saveLater();\n                      }\n\n                      resolve(entry);\n                    })[\"catch\"](function (error) {\n                      console.warn(error);\n                      var entry = new DataCatalogEntry({\n                        dataCatalog: _this4,\n                        namespace: options.namespace,\n                        compute: options.compute,\n                        path: options.path,\n                        definition: options.definition\n                      });\n\n                      if (!options.cachedOnly && options.definition) {\n                        entry.saveLater();\n                      }\n\n                      resolve(entry);\n                    });\n                  }\n                });\n                return _context8.abrupt(\"return\", this.entries[identifier]);\n\n              case 7:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function getEntry(_x13) {\n        return _getEntry.apply(this, arguments);\n      }\n\n      return getEntry;\n    }()\n  }, {\n    key: \"getMultiTableEntry\",\n    value: function () {\n      var _getMultiTableEntry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(options) {\n        var _this5 = this;\n\n        var identifier, newEntry;\n        return regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                identifier = generateEntryCacheId(options);\n\n                if (!this.multiTableEntries[identifier]) {\n                  _context10.next = 3;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", this.multiTableEntries[identifier]);\n\n              case 3:\n                newEntry = new MultiTableEntry({\n                  identifier: identifier,\n                  dataCatalog: this,\n                  paths: options.paths\n                });\n                this.multiTableEntries[identifier] = new Promise( /*#__PURE__*/function () {\n                  var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(resolve) {\n                    var storeEntry;\n                    return regeneratorRuntime.wrap(function _callee9$(_context9) {\n                      while (1) {\n                        switch (_context9.prev = _context9.next) {\n                          case 0:\n                            if (_cacheEnabled) {\n                              _context9.next = 3;\n                              break;\n                            }\n\n                            resolve(newEntry);\n                            return _context9.abrupt(\"return\");\n\n                          case 3:\n                            _context9.prev = 3;\n                            _context9.next = 6;\n                            return _this5.multiTableStore.getItem(identifier);\n\n                          case 6:\n                            storeEntry = _context9.sent;\n\n                            if (storeEntry) {\n                              mergeMultiTableEntry(newEntry, storeEntry);\n                            }\n\n                            _context9.next = 13;\n                            break;\n\n                          case 10:\n                            _context9.prev = 10;\n                            _context9.t0 = _context9[\"catch\"](3);\n                            console.warn(_context9.t0);\n\n                          case 13:\n                            resolve(newEntry);\n\n                          case 14:\n                          case \"end\":\n                            return _context9.stop();\n                        }\n                      }\n                    }, _callee9, null, [[3, 10]]);\n                  }));\n\n                  return function (_x15) {\n                    return _ref5.apply(this, arguments);\n                  };\n                }());\n                return _context10.abrupt(\"return\", this.multiTableEntries[identifier]);\n\n              case 6:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function getMultiTableEntry(_x14) {\n        return _getMultiTableEntry.apply(this, arguments);\n      }\n\n      return getMultiTableEntry;\n    }()\n    /**\n     * Updates the cache for the given multi table entry\n     */\n\n  }, {\n    key: \"persistMultiTableEntry\",\n    value: function () {\n      var _persistMultiTableEntry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(multiTableEntry) {\n        var confTtl;\n        return regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                confTtl = window.CACHEABLE_TTL || {};\n\n                if (!(!_cacheEnabled || confTtl[\"default\"] && confTtl[\"default\"] <= 0 || confTtl.sqlAnalyzer && confTtl.sqlAnalyzer <= 0 || multiTableEntry.getConnector().optimizer === SqlAnalyzerMode.local)) {\n                  _context11.next = 3;\n                  break;\n                }\n\n                return _context11.abrupt(\"return\");\n\n              case 3:\n                _context11.next = 5;\n                return this.multiTableStore.setItem(multiTableEntry.identifier, {\n                  version: DATA_CATALOG_VERSION,\n                  topAggs: multiTableEntry.topAggs,\n                  topColumns: multiTableEntry.topColumns,\n                  topFilters: multiTableEntry.topFilters,\n                  topJoins: multiTableEntry.topJoins\n                });\n\n              case 5:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function persistMultiTableEntry(_x16) {\n        return _persistMultiTableEntry.apply(this, arguments);\n      }\n\n      return persistMultiTableEntry;\n    }()\n  }], [{\n    key: \"disableCache\",\n    value: function disableCache() {\n      _cacheEnabled = false;\n    }\n    /**\n     * Enables the cache for subsequent operations, mainly used for test purposes\n     */\n\n  }, {\n    key: \"enableCache\",\n    value: function enableCache() {\n      _cacheEnabled = true;\n    }\n  }, {\n    key: \"cacheEnabled\",\n    value: function cacheEnabled() {\n      return _cacheEnabled;\n    }\n  }]);\n\n  return DataCatalog;\n}();\nvar generalDataCatalog = new GeneralDataCatalog();\nvar sourceBoundCatalogs = {};\n/**\n * Helper function to get the DataCatalog instance for a given data source.\n */\n\nvar getCatalog = function getCatalog(connector) {\n  if (!connector || !connector.id) {\n    throw new Error('getCatalog called without connector with id');\n  }\n\n  return sourceBoundCatalogs[connector.id] || (sourceBoundCatalogs[connector.id] = new DataCatalog(connector));\n};\n\nexport default {\n  /**\n   * Adds a detached (temporary) entry to the data catalog. This would allow autocomplete etc. of tables that haven't\n   * been created yet.\n   *\n   * Calling this returns a handle that allows deletion of any created entries by calling delete() on the handle.\n   */\n  addTemporaryTable: function addTemporaryTable(options) {\n    return getCatalog(options.connector).addTemporaryTable(options);\n  },\n  getEntry: function getEntry(options) {\n    return getCatalog(options.connector).getEntry(options);\n  },\n  getMultiTableEntry: function getMultiTableEntry(options) {\n    return getCatalog(options.connector).getMultiTableEntry(options);\n  },\n\n  /**\n   * This can be used as a shorthand function to get the child entries of the given path. Same as first calling\n   * getEntry then getChildren.\n   */\n  getChildren: function getChildren(options) {\n    return new CancellablePromise( /*#__PURE__*/function () {\n      var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(resolve, reject, onCancel) {\n        var entry, childPromise;\n        return regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.prev = 0;\n                _context12.next = 3;\n                return getCatalog(options.connector).getEntry(options);\n\n              case 3:\n                entry = _context12.sent;\n                childPromise = entry.getChildren(options);\n                onCancel(function () {\n                  childPromise.cancel();\n                });\n                resolve(applyCancellable(childPromise, options));\n                _context12.next = 12;\n                break;\n\n              case 9:\n                _context12.prev = 9;\n                _context12.t0 = _context12[\"catch\"](0);\n                reject(_context12.t0);\n\n              case 12:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, null, [[0, 9]]);\n      }));\n\n      return function (_x17, _x18, _x19) {\n        return _ref6.apply(this, arguments);\n      };\n    }());\n  },\n  getCatalog: getCatalog,\n  getAllNavigatorTags: generalDataCatalog.getAllNavigatorTags.bind(generalDataCatalog),\n  updateAllNavigatorTags: generalDataCatalog.updateAllNavigatorTags.bind(generalDataCatalog),\n  enableCache: function enableCache() {\n    _cacheEnabled = true;\n  },\n  disableCache: function disableCache() {\n    _cacheEnabled = false;\n  }\n};","// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nexport var REFRESH_CONTEXT_CATALOG_TOPIC = 'context.catalog.refresh';\nexport var CONTEXT_CATALOG_REFRESHED_TOPIC = 'context.catalog.refreshed';\nexport var NAMESPACES_REFRESHED_TOPIC = 'context.catalog.namespaces.refreshed';"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;;;;;;;;;;;;ACl9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;;;;;;;;;;;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;;;;;;;;;ACpOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;;;;;;;;;;;;;;;AChPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;;;;;;;;;ACzaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;;;;;;;;;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;;;;;;;;;ACn3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;;;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;;;;;;;;;;;;;;;;;ACrgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;;;;;;;;;;AC1pCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;A","sourceRoot":""}